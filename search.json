[{"title":"Java的IO模型","path":"/2024/02/05/nio/02【Java的IO模型】/","content":"文章目录 二、Java的IO模型 2.1 Java的IO模型支持 2.2 BIO（blocking I&#x2F;O）模型 2.3 NIO（non-blocking I&#x2F;O）模型 2.3.1 Buffer（缓冲区） 2.3.2 Channel（通道） 2.3.3 Selector（选择器） 2.3 AIO模型 2.4 JavaIO模型小结 二、Java的IO模型2.1 Java的IO模型支持Java共支持3种网络编程模型&#x2F;IO模式，分别是： BIO（同步阻塞IO） NIO（同步非阻塞IO） AIO（异步非阻塞IO） 我们可以根据不同的业务场景来决定选择不同I&#x2F;O处理模型； 2.2 BIO（blocking I&#x2F;O）模型 BIO（blocking I/O）：也叫同步阻塞IO，在JDK1.4之前，我们建立网络连接的时候采用的是 BIO 模式。 阻塞 IO（BIO）是最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象，直至有可供读取的数据或者数据能够写入。 在BIO模式中，服务器会为每个客户端的请求创建一个对应的线程来处理，由该线程单独负责处理一个客户请求，如果这个连接不做任何事情会造成不必要的线程开销，为此我们可以通过线程池机制改善性能； 虽然使用线程池可以一定程度上改善BIO的性能，但依旧无法冲本质上解决BIO同步阻塞的的问题；如果连接大多是长连接，则会导致连接无法释放，新的请求将无法得到处理，另外，BIO这种一个请求对应一个线程的方式在应对高并发的情况下，服务器必须也要创建同等量的线程来处理客户端的请求，这样对系统的消耗是非常大的； BIO优点： 实现简单，IO模式适用于连接数目比较小且固定的架构，是JDK1.4以前的唯一选择； BIO缺点： 1）每个请求都需要创建独立的线程来处理，当连接数较大时，需要创建大量的线程来处理 2）一个线程只能处理一个请求，连接建立后，如果当前线程暂时没有数据可读，那么该线程就一直阻塞在读操作，并不能处理其他事情，造成性能浪费； 2.3 NIO（non-blocking I&#x2F;O）模型NIO是从JDK1.4版本开始引入的一个新的IO API，NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。 BIO是同步阻塞IO，同步：即在同一时间点只能同时处理一个客户端连接，阻塞：即当调用方法获取数据时，如果没有可用的数据将会阻塞当前线程； NIO则是同步非阻塞IO，NIO中有三大组件，分别是：Channel（通道），Buffer（缓冲区），Selector（选择器）；当有客户端连接时，服务器可以获取与该客户端的连接Channel（通道），所有的通道都会被注册到Selector（选择器）上，当Channel上有读写数据时将会被Selector侦测到，服务器只需要派发一个线程来处理Selector上的事件即可；当前Channel如果没有读写数据时，Selector并不会一直阻塞的等待Channel的数据返回，而是轮询式的侦测所有的Channel，这是NIO非阻塞的核心； 另外，客户端的连接都变成了Channel，这些Channel都注册到了Selector中，服务器再也不需要为每一个连接来创建一个独立的线程为之服务了；这也是NIO能够应对高并发的核心之一； NIO（non-blocking IO）：也叫同步非阻塞IO，由于BIO的各种弊端，JDK1.4从开始提供了一系列改进的输入&#x2F;输出的新特性，被统称为 NIO(即 New IO)，是同步非阻塞的。NIO相关类都被放在java.nio包及子包下，并且对原java.io包中的很多类进行改写。 在NIO模型中，每个请求都会有一个与服务器做数据交互的通道（Channel），所有的通道都被注册到一个选择器中（selector），当需要与服务器做数据交互时，数据通过管道写入到一个缓冲区（Buffer）中，服务器通过往缓冲区中读取数据，如果当前通道没有数据时，就什么都不会获取，而不是保持线程阻塞，直至数据变的可以读取之前，该线程可以继续做其他的事情。 在Java NIO有三大核心部分：Buffer（缓冲区）、Channel（通道）、Selector（选择器） ； 2.3.1 Buffer（缓冲区）Buffer本质上就是一块存储数据的内存，我们可以在这一块内存中进行读写操作，这与我们之前的数组非常类似。与数组不同的是，这块内存被封装成Buffer对象，并根据不同的数据类型提供有不同的Buffer子类。Java对Buffer提供了更多的API，使得Buffer功能更加强大； Java中常见的Buffer如下： CharBuffer DoubleBuffer IntBuffer LongBuffer ByteBuffer ShortBuffer FloatBuffer Tips：以上Buffer都继承与Buffer抽象类，StringBuffer和以上的Buffer并不是同一类的，没有继承与NIO包下的Buffer接口； 2.3.2 Channel（通道）Java NIO的通道类似流，都是用于传输数据的。但通过又与流有些不同；流的数据走向是单向的，分为输入流（只能读取数据），输出流（只能写出数据），但NIO中的通道不一样，通道既可以写数据到Buffer，又可以从Buffer中读取数据； 另外流的操作对象是数组，而通道的操作对象是Buffer； Java中常见的Channel如下： FileChannel：用于文件 I&#x2F;O 编程 SocketChannel、ServerSocketChannel：用于 TCP I&#x2F;O 编程 DatagramChannel：用于 UDP I&#x2F;O 编程 2.3.3 Selector（选择器）Selector选择器，也叫多路复用器；NIO中实现非阻塞 I&#x2F;O 的核心对象就是 Selector。当一个连接创建后，不需要创建一个线程来处理这个来连接，这个连接（管道）会被注册到选择器上，选择器可以检查一个或多个 NIO 通道，并确定哪些通道已经准备好进行读取或写入。这样，一个单独的线程可以管理多个channel，系统不必创建大量的线程，也不必维护这些线程，从而大大减小了系统的开销。 2.3 AIO模型 AIO ：AIO也叫异步非阻塞，JDK1.7之后的新特性，AIO引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。 与NIO模型不同，读写操作为例，只需直接调用read和write的API即可，这方法都是异步的对于读操作:当有流可读是，系统会将可读的流传入到read方法的缓冲区，并通知应用程序读写都是异步的，完成之后会主动调用回调函数 AIO需要操作系统的支持，在Linux内核2.6版本之后增加了对真正异步IO的实现。Java从JDK1.7之后支持AIO，JDK1.7新增一些与文件&#x2F;网络IO相关的一些API，称之为NIO2.0或者称之为AIO（Asynchronous IO）。AIO最大的特征提供了异步功能，对于socket网络通信和文件IO都是起作用的。 目前 AIO 还没有广泛应用，Netty也是基于NIO，而不是AIO。 2.4 JavaIO模型小结 BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解； NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持； AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如文件服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。 仅限学习、交流使用！ QQ群名片 本文转自 https://blog.csdn.net/Bb15070047748/article/details/125438283，如有侵权，请联系删除。","tags":["nio"]},{"title":"05 NIO核心组件之Channel","path":"/2024/02/05/nio/05【NIO核心组件之Channel】/","content":"文章目录 五、NIO核心组件之Channel 5.1 FileChannel 5.1.1 FileChannel的基本使用 5.1.2 FileChannel的常用方法 1）truncate 2）size 3）position 4）force 5）transferFrom 6）transferTo 5.1.3 聚集和分散 5.2 DatagramChannel 5.2.1 DatagramChannel简介 5.2.2 DatagramChannel的获取 5.2.3 DatagramChannel的常用方法 1）发送和接收 2）读取和写入 5.3 SocketChannel与ServerSocketChannel 5.3.1 Channel的简介 5.3.2 Channel的获取 5.3.3 Channel的常用方法 1）基本读写 2）拷贝图片案例 3）在线聊天案例 五、NIO核心组件之ChannelJava NIO的通道类似流，都是用于传输数据的。但通过又与流有些不同；流的数据走向是单向的，分为输入流（只能读取数据），输出流（只能写出数据），但NIO中的通道不一样，通道既可以写数据到Buffer，又可以从Buffer中读取数据； 另外流的操作对象是数组，而通道的操作对象是Buffer； Java中常见的Channel如下： FileChannel：用于文件 I&#x2F;O 编程 SocketChannel、ServerSocketChannel：用于 TCP I&#x2F;O 编程 DatagramChannel：用于 UDP I&#x2F;O 编程 5.1 FileChannelFileChannel是用于文件I&#x2F;O编程的管道类；通过FileInputStream和FileOutputStream可以获取一个关联文件的Channel，即FileChannel； public FileChannel getChannel()：获取该流的Channel； 示例代码： 12345// 通过输入流获取Channel,该Channel只能读取数据FileChannel inChannel = new FileInputStream(&quot;&quot;).getChannel();// 通过输出流获取Channel,该Channel只能写出数据FileChannel outChannel = new FileOutputStream(&quot;&quot;).getChannel(); 我们可以读取Channel中的数据，也可以往Channel中写数据，Channel是可读可写的；但FileChannel最终需要将数据写入到对应的输入&#x2F;输出流，因为流是有顺序的，输入流只能读取数据，而输出流只能写出数据，因此使用FileInputStream&#x2F;FileOutputStream获取到的FileChannel只能读或写； 5.1.1 FileChannel的基本使用 int read(ByteBuffer dst)：从Channel中读取数据，写入到Buffer中，返回读取到的有效字节个数，读取到末尾返回-1 int write(ByteBuffer src)：从Buffer中读取数据，写入到Channel中，返回写出的有效字节个数，如果没有数据写出返回0 案例1：通过Channel输出数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.dfbz.channel.fileChannel;import org.junit.Test;import java.io.FileInputStream;import java.io.FileOutputStream;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;/** * @author lscl * @version 1.0 * @intro: */public class Demo01_FileChannel的基本使用 &#123; @Test public void writer() throws Exception &#123; // 1. 创建一个输出流 FileOutputStream fos = new FileOutputStream(&quot;001.txt&quot;); // 2. 通过输出流获取Channel FileChannel channel = fos.getChannel(); // 3. 创建一个Buffer ByteBuffer buffer = ByteBuffer.allocate(1024); buffer.put(&quot;hello&quot;.getBytes()); // 4. 切换读模式(limit=position=5;position=0) buffer.flip(); // 5. 将Buffer的数据读出来,写入到Channel中 int len = channel.write(buffer); // System.out.println(&quot;写出的有效字节个数: &quot; + len); // 5 len = channel.write(buffer); System.out.println(&quot;写出的有效字节个数: &quot; + len); // 0 channel.close(); fos.close(); &#125;&#125; 注意：channel.write()方法是将数据从Buffer中读取出来，然后写入到Channel中，这对Buffer本质上是一次读操作，我们对Buffer的任何读写操作都会造成Buffer中的position位移； 再次测试： 1234567891011121314151617181920212223242526272829303132@Testpublic void writer_02() throws Exception &#123; // 1. 创建一个输出流 FileOutputStream fos = new FileOutputStream(&quot;001.txt&quot;); // 2. 通过输出流获取Channel FileChannel channel = fos.getChannel(); // 3. 创建一个Buffer ByteBuffer buffer = ByteBuffer.allocate(1024); System.err.println(buffer); // position=0,limit=capacity=1024 buffer.put(&quot;hello&quot;.getBytes()); System.err.println(buffer); // position=5,limit=capacity=1024 // 4. 切换读模式(limit=position=5;position=0) buffer.flip(); System.err.println(buffer); // position=0,limit=5,capacity=1024 // 5. 将Buffer的数据读出来(也会造成position的位移),写入到Channel中 int len = channel.write(buffer); // System.out.println(&quot;写出的有效字节个数: &quot; + len); // 5 len = channel.write(buffer); System.out.println(&quot;写出的有效字节个数: &quot; + len); // 0 System.err.println(buffer); // position=5,limit=5,capacity=1024 channel.close(); fos.close();&#125; 执行程序，查看控制台： 案例2：通过Channel读取数据 123456789101112131415161718192021222324252627282930@Testpublic void reader() throws Exception &#123; // 1. 创建一个输入流 FileInputStream fis = new FileInputStream(&quot;001.txt&quot;); // 2. 通过输入流获取Channel FileChannel channel = fis.getChannel(); // 3. 创建一个Buffer ByteBuffer buffer = ByteBuffer.allocate(1024); // 4. 从Channel中读取数据,写入到Buffer中 int len = channel.read(buffer); System.out.println(&quot;读取到的有效字节个数: &quot; + len); // 5 len = channel.read(buffer); System.out.println(&quot;读取到的有效字节个数: &quot; + len); // -1 // limit=position,position=0 buffer.flip(); byte[] data = new byte[buffer.limit()]; buffer.get(data); // 从Buffer中读取数据 System.out.println(new String(data, 0, data.length)); channel.close(); fis.close();&#125; 注意：和write方法一样，channel调用read方法是将数据从Channel读取出来，往Buffer中写入，这对Buffer来说本质上是一种写的操作，我们对Buffer的任何读写操作都会造成Buffer中的position位移； 再次测试： 12345678910111213141516171819202122232425262728293031@Testpublic void reader_01() throws Exception &#123; // 1. 创建一个输入流 FileInputStream fis = new FileInputStream(&quot;001.txt&quot;); // 文件内容: hello // 2. 通过输入流获取Channel FileChannel channel = fis.getChannel(); // 3. 创建一个Buffer ByteBuffer buffer = ByteBuffer.allocate(1024); System.err.println(buffer); // position=0,limit=capacity=1024 // 4. 从Channel中读取数据,写入到Buffer中(会造成position的位移) channel.read(buffer); System.err.println(buffer); // position=5,limit=capacity=1024 // limit=position=5,position=0,capacity=1024 buffer.flip(); System.err.println(buffer); // position=0,limit=5,capacity=1024 byte[] data = new byte[buffer.limit()]; // 从Buffer中读取数据 buffer.get(data); System.err.println(buffer); // position=5,limit=5,capacity=1024 System.out.println(new String(data, 0, data.length)); channel.close(); fis.close();&#125; 执行程序，查看控制台： 案例3-使用FileChannel拷贝文件： 1234567891011121314151617181920212223242526272829@Testpublic void copy() throws Exception &#123; FileInputStream fis = new FileInputStream(&quot;100.png&quot;); FileOutputStream fos = new FileOutputStream(&quot;200.png&quot;); FileChannel inChannel = fis.getChannel(); FileChannel outChannel = fos.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(1024); // 读取Channel中的数据,写入到Buffer中 while (inChannel.read(buffer) != -1) &#123; // limit=position,position=0 buffer.flip(); // 从Buffer中读取数据,写入Channel中 outChannel.write(buffer); // limit=capacity,position=0 buffer.clear(); &#125; inChannel.close(); outChannel.close(); fis.close(); fos.close();&#125; 5.1.2 FileChannel的常用方法 FileChannel truncate(long s)：将此通道的文件截取为给定大小 long size()：返回此通道的文件的当前大小 long position()：返回该Channel目前所在的文件位置； FileChannel position(long p)：设置该Channel目前所在的文件位置； public void force(boolean metaData)：将当前Channel中的数据强制写入到磁盘中 public long transferFrom(ReadableByteChannel src, long position, long count)：从src的position位置开始读取，读取count个字节到当前Channel中 public long transferTo(long position, long count,WritableByteChannel target)：从当前Channel的position位置开始读取，读取count个字节到target中 long write(ByteBuffer[] srcs) 将ByteBuffer[]到中的数据全部写入（聚集）到 Channel long read(ByteBuffer[] dsts) 将Channel到中的数据读取出来，然后全部写入（分散）到ByteBuffer[] 1）truncate FileChannel truncate(long s)：将此通道的文件截取为给定大小； 可以使用FileChannel.truncate()方法截取一个文件。截取文件时，文件将中指定长度后面的部分将被删除。 123456789101112131415161718192021222324@Testpublic void truncate() throws Exception &#123; FileInputStream stream = new FileInputStream(&quot;001.txt&quot;); // 文件内容: hello// FileOutputStream stream = new FileOutputStream(&quot;001.txt&quot;); // 文件内容: hello // 创建流(可读可写)// RandomAccessFile stream = new RandomAccessFile(&quot;001.txt&quot;, &quot;rw&quot;); // 文件内容: hello // 获取Channel FileChannel channel = stream.getChannel(); // 将Channel的文件截取为2 channel.truncate(2); // 使用FileInputStream出现: java.nio.channels.NonWritableChannelException ByteBuffer buffer = ByteBuffer.allocate(10); channel.read(buffer); // 使用FileOutputStream出现: java.nio.channels.NonReadableChannelException System.out.println(new String(buffer.array(), 0, buffer.array().length)); // he stream.close(); channel.close();&#125; Tips：FileInputStream只能读取数据，因此使用FileInputStream获取的FileChannel也只能读取数据；同理FileOutputStream只能写出数据，使用FileOutputStream获取FileChannel也只能写出数据；因此上述案例中使用RandomAccessFile，即可读又可写； 2）sizeFileChannel实例的size()方法将返回该实例所关联文件的大小。 long size()：返回此通道的文件的当前大小 12345678@Testpublic void size() throws Exception &#123; FileInputStream fis = new FileInputStream(&quot;001.txt&quot;); FileChannel channel = fis.getChannel(); System.out.println(channel.size()); // 5&#125; 3）position long position()：返回该Channel目前所在的文件位置； 有时可能需要在FileChannel的某个特定位置进行数据的读&#x2F;写操作。可以通过调用position()方法获取FileChannel的当前位置。也可以通过调用position(long pos)方法设置FileChannel的当前位置。 测试position： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.dfbz.channel;import org.junit.Test;import java.io.FileInputStream;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;/** * @author lscl * @version 1.0 * @intro: */public class Demo02_常用方法 &#123; @Test public void position() throws Exception &#123; FileInputStream fis = new FileInputStream(&quot;001.txt&quot;); FileChannel channel = fis.getChannel(); // 获取此Channel的读写位置(默认为0) System.out.println(channel.position()); // 0 ByteBuffer buffer = ByteBuffer.allocate(1024); // 从Channel中读取数据到buffer中,读取了5个有效字节 channel.read(buffer); System.out.println(&quot;buffer中的内容: &quot; + new String(buffer.array(), 0, buffer.array().length)); System.out.println(&quot;---------------------&quot;); // limit=capacity,position=0 buffer.clear(); System.out.println(channel.position()); // 5 // 将channel的读取位置设置为2 channel.position(2); channel.read(buffer); System.out.println(&quot;buffer中的内容: &quot; + new String(buffer.array(), 0, buffer.array().length)); &#125;&#125; Tips：如果将位置设置在文件结束符之后，然后试图从文件通道中读取数据，读方法将返回-1 —— 文件结束标志。 如果将位置设置在文件结束符之后，然后向通道中写数据，文件将撑大到当前位置并写入数据。这可能导致“文件空洞”，磁盘上物理文件中写入的数据间有空隙。 测试position-2： 123456789101112131415161718@Testpublic void position2() throws Exception &#123; // 创建流(可读可写) RandomAccessFile raf = new RandomAccessFile(&quot;001.txt&quot;, &quot;rw&quot;); // 文件内容: hello // 获取Channel FileChannel channel = raf.getChannel(); // 将position设置为size+10(空隙) channel.position(channel.size()+10); // 往Channel写出数据 channel.write(ByteBuffer.wrap(&quot;abc&quot;.getBytes())); raf.close(); channel.close();&#125; 001.txt文件内容如下： 4）force public void force(boolean metaData)：将当前Channel中的数据强制写入到磁盘中 FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用force()方法。 另外，force()方法有一个boolean类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上 测试代码： 123456789101112131415161718192021@Testpublic void force() throws Exception &#123; // 创建流(可读可写) RandomAccessFile raf = new RandomAccessFile(&quot;001.txt&quot;, &quot;rw&quot;); // 文件内容: hello // 获取Channel FileChannel channel = raf.getChannel(); channel.write(ByteBuffer.wrap(&quot;Hello Everyone!&quot;.getBytes())); /* 将内存中的数据强制写入到磁盘中 true: 将文件元信息(权限信息等)写入磁盘 false: 不写入文件元信息到磁盘 */ channel.force(true); raf.close(); channel.close();&#125; 5）transferFrom public long transferFrom(ReadableByteChannel src, long position, long count)：从src的position位置开始读取，读取count个字节到当前Channel中 FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中 123456789101112131415@Testpublic void transferFrom() throws Exception &#123; RandomAccessFile fromFile = new RandomAccessFile(&quot;001.txt&quot;, &quot;rw&quot;); FileChannel fromChannel = fromFile.getChannel(); RandomAccessFile toFile = new RandomAccessFile(&quot;002.txt&quot;, &quot;rw&quot;); FileChannel toChannel = toFile.getChannel(); long position = 0; long count = fromChannel.size(); // 从fromChannel的position位置开始读取,读取count个字节到toChannel中 toChannel.transferFrom(fromChannel, position, count);&#125; 6）transferTo public long transferTo(long position, long count,WritableByteChannel target)：从当前Channel的position位置开始读取，读取count个字节到target中 transferTo()方法将数据从FileChannel传输到其他的channel中 123456789101112131415@Testpublic void transferTo() throws Exception &#123; RandomAccessFile fromFile = new RandomAccessFile(&quot;001.txt&quot;, &quot;rw&quot;); FileChannel fromChannel = fromFile.getChannel(); RandomAccessFile toFile = new RandomAccessFile(&quot;002.txt&quot;, &quot;rw&quot;); FileChannel toChannel = toFile.getChannel(); long position = 0; long count = fromChannel.size(); // 从fromChannel的position位置开始读取,读取count到toChannel中 fromChannel.transferTo(position, count, toChannel);&#125; 5.1.3 聚集和分散 聚集（gather）：写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel 将多个Buffer中的数据“聚集（gather）”后发送到Channel。 分散（scatter）：从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。 scatter &#x2F; gather经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的buffer中，这样你可以方便的处理消息头和消息体。 long write(ByteBuffer[] srcs) 将ByteBuffer[]到中的数据全部写入（聚集）到 Channel long read(ByteBuffer[] dsts) 将Channel到中的数据读取出来，然后全部写入（分散）到ByteBuffer[] Gathering Writes（聚集）：是指数据从多个buffer写入到同一个channel。如下图描述： Scattering Reads（分散）：是指数据从一个channel读取到多个buffer中。如下图描述： 测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.dfbz.channel;import org.junit.Test;import java.io.IOException;import java.io.RandomAccessFile;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;/** * @author lscl * @version 1.0 * @intro: */public class Demo03_聚集和分散 &#123; // 聚集 @Test public void gather() throws IOException &#123; RandomAccessFile raf = new RandomAccessFile(&quot;004.txt&quot;, &quot;rw&quot;); FileChannel channel = raf.getChannel(); ByteBuffer header = ByteBuffer.wrap(&quot;&#123;&#x27;content-Type&#x27;:&#x27;application/json&#x27;&#125;&quot;.getBytes()); ByteBuffer body = ByteBuffer.wrap(&quot;&#123;&#x27;username&#x27;:&#x27;admin&#x27;,&#x27;password&#x27;:&#x27;123&#x27;&#125;&quot;.getBytes()); ByteBuffer[] bufferArray = &#123;header, body&#125;; // 将多个Buffer聚集到一起写入到channel中 channel.write(bufferArray); channel.close(); raf.close(); &#125; // 分散 @Test public void test2() throws IOException &#123; RandomAccessFile raf = new RandomAccessFile(&quot;004.txt&quot;, &quot;rw&quot;); FileChannel channel = raf.getChannel(); ByteBuffer header = ByteBuffer.allocate(&quot;&#123;&#x27;content-Type&#x27;:&#x27;application/json&#x27;&#125;&quot;.getBytes().length); ByteBuffer body = ByteBuffer.allocate(&quot;&#123;&#x27;username&#x27;:&#x27;admin&#x27;,&#x27;password&#x27;:&#x27;123&#x27;&#125;&quot;.getBytes().length); ByteBuffer[] bufferArray = &#123;header, body&#125;; // 将channel中的数据分散读取,然后逐个写入到每个Buffer中 channel.read(bufferArray); for (ByteBuffer buffer : bufferArray) &#123; System.out.println(new String(buffer.array(),0,buffer.array().length)); &#125; channel.close(); raf.close(); &#125;&#125; 5.2 DatagramChannel5.2.1 DatagramChannel简介DatagramChannel是用于UDP编程的Channel；获取到了DatagramChannel之后，可以使用Channel直接发送Buffer数据；因为UDP是无连接的网络协议，因此使用DatagramChannel发送的Buffer数据在发送时都会被封装成UDP报文，并且存在UDP协议的特性； 发送和接收报文： 在使用DatagramChannel发送数据时，必须通过InetSocketAddress类来指定接收端的地址和端口；而在接收数据时，接收端的Channel必须先通过InetSocketAddress类绑定一个地址和端口； 读取和写入数据： DatagramChannel不仅可以发送报文和接收报文，还可以读取DatagreamChannel中的数据，或往DatagreamChannel中写入数据；与发送和接收不同，在使用DatagramChannel发送或接收时，DatagramChannel充当一个接收器&#x2F;发送器的角色，自己本身并不存储那些数据；而是将数据接收到一个Buffer中，而在使用DatagramChannel读取&#x2F;写入数据时，数据可以从Buffer中读取到Channel中，也可以从Channel写出到Buffer； 5.2.2 DatagramChannel的获取在Java NIO中，我们可以通过DatagreamChannel来直接打开一个Channel，也可以DatagreamSocket可以获取到一个属于该Socket的Channel，但该Socket必须是由Channel获取的Socket；这两种方式获取到的Channel是同一个； DatagreamChannel方法： public static DatagramChannel open() ：打开一个基于UDP协议的Channel管道； public DatagramSocket socket()：通过Channel获取一个Socket； DatagreamSocket方法： public DatagramChannel getChannel()：获取该Socket的Channel管道； 测试代码： 123456789101112131415161718192021222324252627282930313233343536373839package com.dfbz.channel.datagramChannel;import org.junit.Test;import java.net.DatagramSocket;import java.nio.channels.DatagramChannel;/** * @author lscl * @version 1.0 * @intro: */public class Demo01_DatagramChannel的获取 &#123; @Test public void test() throws Exception &#123; // 通过DatagramChannel打开一个Channel DatagramChannel channel = DatagramChannel.open(); // 通过channel也可以获取一个socket DatagramSocket socket = channel.socket(); // 通过socket也可以获取Channel DatagramChannel channel2 = socket.getChannel(); System.out.println(channel2.getClass()); // class sun.nio.ch.DatagramChannelImpl System.out.println(channel == channel2); // true &#125; @Test public void test2() throws Exception &#123; DatagramSocket socket = new DatagramSocket(9999); // 不能通过DatagramSocket来获取channel DatagramChannel channel = socket.getChannel(); System.out.println(channel); // null &#125;&#125; 5.2.3 DatagramChannel的常用方法 public DatagramChannel bind(SocketAddress local)：绑定当前客户端的地址和端口，其他Channel向当前Channel发送数据时指定的地址。在接收UDP报文时，必须先绑定； public SocketAddress receive(ByteBuffer dst)：接收UDP报文，将接收到的UDP报文赋值给dst； public int send(ByteBuffer src, SocketAddress target)：发送一个UDP报文；并指定报文要发送的地址和端口 public DatagramChannel connect(SocketAddress remote)：用于连接其他的DatagramChannel ，DatagramChannel之间建立连接后可以相互读取&#x2F;写入数据； Tips：由于UDP是无连接的，使用connect方法连接到特定地址并不会像TCP通道那样创建一个真正的连接。而是锁住DatagramChannel ，让其只能从特定地址收发数据。因此即使是连接的地址不存在，也不会报错； 1）发送和接收测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.dfbz.channel.datagramChannel;import org.junit.Test;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.DatagramChannel;/** * @author lscl * @version 1.0 * @intro: */public class Demo02_发送和接收 &#123; /** * 发送端 * * @throws Exception */ @Test public void sender() throws Exception &#123; // 通过DatagramChannel打开一个Channel DatagramChannel channel = DatagramChannel.open(); // 往该Channel写入数据 channel.send(ByteBuffer.wrap(&quot;hello&quot;.getBytes()), new InetSocketAddress(&quot;127.0.0.1&quot;, 9999)); channel.close(); &#125; /** * 接收端 * * @throws Exception */ @Test public void receive() throws Exception &#123; // 通过DatagramChannel打开一个Channel DatagramChannel channel = DatagramChannel.open(); // 绑定地址(用于接收该地址发送过来的数据) channel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 9999)); ByteBuffer buffer = ByteBuffer.allocate(1024); // 使用Buffer接收报文 channel.receive(buffer); System.out.println(new String(buffer.array(), 0, buffer.array().length)); &#125;&#125; 2）读取和写入 读取端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.dfbz.channel.datagramChannel;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.DatagramChannel;/** * @author lscl * @version 1.0 * @intro: */public class Demo03_读取端 &#123; public static void main(String[] args) throws Exception &#123; // 获取Channel DatagramChannel channel = DatagramChannel.open(); /* 绑定一个地址 1) 用于接收该地址发送的UDP报文 2) 用于其他DatagramChannel与当前Channel建立连接(逻辑连接),待会可以使用Channel从127.0.0.1的9999端口读取数据 */ channel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 9999)); /* 连接一个地址: 1) 建立一个UDP逻辑连接,如果需要读取127.0.0.2主机的数据则必须建立逻辑连接 2) 建立好逻辑连接后,可以使用channel向127.0.0.2主机写入数据 */ channel.connect(new InetSocketAddress(&quot;127.0.0.2&quot;, 9999)); System.out.println(&quot;开始接收数据: &quot;); System.out.println(&quot;----------------&quot;); // 创建Buffer,用读取Channel中的数据 ByteBuffer readBuffer = ByteBuffer.allocate(1024); // position=0,limit=1024,capacity=1024 while (true) &#123; // 将数据从Channel中读取出来,写入到readBuffer中 channel.read(readBuffer); // 预备下次一次从Channel读出数据写入到Buffer中[position=0,limit=capacity] readBuffer.clear(); System.out.println(&quot;接收到来自【&quot; + channel.getRemoteAddress() + &quot;】的数据: &quot; + new String(readBuffer.array(), 0, readBuffer.array().length)); &#125; &#125;&#125; 写入端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.dfbz.channel.datagramChannel;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.DatagramChannel;import java.util.Scanner;/** * @author lscl * @version 1.0 * @intro: */public class Demo04_写入端 &#123; public static void main(String[] args) throws Exception &#123; // 获取Channel DatagramChannel channel = DatagramChannel.open(); /* 绑定一个地址 1) 用于接收该地址发送的UDP报文 2) 用于其他DatagramChannel与当前Channel建立连接(逻辑连接),待会可以使用Channel从127.0.0.2的9999端口读取数据 */ channel.bind(new InetSocketAddress(&quot;127.0.0.2&quot;, 9999)); // 连接一个地址: 与指定的地址建立逻辑连接,用于向这个地址发送数据,待会可以使用Channel向写入数据到127.0.0.1的9999端口 channel.connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 9999)); // 创建Buffer ByteBuffer writeBuffer = ByteBuffer.allocate(1024); // position=0,limit=1024,capacity=1024 // 获取一个扫描器 Scanner scanner = new Scanner(System.in); while (true) &#123; System.out.println(&quot;请输入数据: &quot;); // 接收控制台输入的数据 String str = scanner.nextLine(); // 将控制台输入的数据添加到buffer中 writeBuffer.put(str.getBytes()); // buffer的position会进行位移 // limit=position,position=0 writeBuffer.flip(); // 从Buffer中读取数据出来,往Channel中写入数据 // buffer的position会进行位移 channel.write(writeBuffer); // position=0,limit=capacity(预备下一次写入) writeBuffer.clear(); System.out.println(&quot;使用Channel向【&quot; + channel.getRemoteAddress() + &quot;】发送了数据: &quot; + str); &#125; &#125;&#125; 使用一个Channel进行读取和写入： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.dfbz.channel.datagramChannel;import org.junit.Test;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.DatagramChannel;/** * @author lscl * @version 1.0 * @intro: */public class Demo05_读取和写入 &#123; /** * 读取/写入数据 * * @throws Exception */ @Test public void readerAndWriter() throws Exception &#123; // 获取Channel DatagramChannel channel = DatagramChannel.open(); /* 绑定一个端口(本机) 1) 接收127.0.0.1主机9999端口发送的UDP报文 2) 用于其他DatagramChannel与当前Channel建立连接(逻辑连接),待会可以使用Channel从127.0.0.1的9999端口读取数据 */ channel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 9999)); /* 连接一个地址: 1) 建立一个UDP逻辑连接,如果需要读取127.0.0.2主机的数据则必须建立逻辑连接 2) 建立好逻辑连接后,可以使用channel向127.0.0.2主机写入数据 */ channel.connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 9999)); // 创建Buffer,用于往Channel写入数据 ByteBuffer writeBuffer = ByteBuffer.wrap(&quot;hello&quot;.getBytes()); // position=0,limit=5,capacity=5 // 创建Buffer,用读取Channel中的数据 ByteBuffer readBuffer = ByteBuffer.allocate(1024); // position=0,limit=1024,capacity=1024 while (true) &#123; // 将数据从writeBuffer中读取出来,写入到Channel中 channel.write(writeBuffer); // writeBuffer:[position=5,limit=5,capacity=5] // 切换写模式读模式,writeBuffer:[position=0,limit=5,capacity=5] writeBuffer.flip(); // 将数据从Channel中读取出来,写入到readBuffer中 channel.read(readBuffer); // readBuffer:[position=5,limit=1024,capacity=1024] // 切换写模式,readBuffer:[position=0,limit=1024,capacity=1024] readBuffer.clear(); System.out.println(&quot;Channel的数据: &quot; + new String(readBuffer.array(), 0, readBuffer.array().length)); Thread.sleep(1000); &#125; &#125;&#125; 5.3 SocketChannel与ServerSocketChannel5.3.1 Channel的简介BIO中Socket编程的两个核心类分别为：Socket（代表客户端）和ServerSocket（代表服务器端），通过ServerSocket的accept可以接收一个客户端的Socket； 在NIO中，提供有SocketChannel和ServerSocketChannel，分别代表客户端和服务端；底层依旧采用TCP协议进行数据的网络传输，同时这些Channel还支持非阻塞方式运行，这一点与原生的Socket&#x2F;ServerSocket有很大的不同；例如ServerSocketChannel在接收一个客户端时，如果还未有客户端来连接服务端，那么accept会返回null，而不是将当前线程阻塞； 5.3.2 Channel的获取通过ServerSocketChannel也可以来获取一个SocketChannel；也可以和DatagramChannel一样，通过open方法来打开一个管道；并且通过Socket可以获取SocketChannel，通过ServerSocket可以获取ServerSocketChannel； 和DatagramChannel一样，虽然通过Socket可以获取Channel，但该Socket必须是由Channel获取的Socket；因为原生的Socket的getChannel()方法永远返回的是null； 测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.dfbz.channel.socketChannel;import org.junit.Test;import java.net.ServerSocket;import java.net.Socket;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;/** * @author lscl * @version 1.0 * @intro: */public class Demo01_Channel的获取 &#123; @Test public void test1() throws Exception &#123; // 获取socketChannel SocketChannel socketChannel = SocketChannel.open(); // 通过channel获取socket Socket socket = socketChannel.socket(); // 通过socket也可以获取对应的Channel System.out.println(socket.getChannel() == socketChannel); // true System.out.println(socket.getClass()); // class sun.nio.ch.SocketAdaptor(并不是一个原生的Socket对象) // serverSocketChannel ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); // 通过channel获取socket ServerSocket serverSocket = serverSocketChannel.socket(); // 通过socket也可以获取对应的Channel System.out.println(serverSocket.getChannel() == serverSocketChannel); // true System.out.println(serverSocket.getClass()); // class sun.nio.ch.ServerSocketAdaptor(并不是一个原生的ServerSocket对象) &#125; @Test public void test2() throws Exception &#123; // 原生的socket并不能获取Channel Socket socket = new Socket(); SocketChannel socketChannel = socket.getChannel(); System.out.println(socketChannel); // null // 原生的ServerSocket并不能获取Channel ServerSocket serverSocket = new ServerSocket(); ServerSocketChannel serverSocketChannel = serverSocket.getChannel(); System.out.println(serverSocketChannel); // null &#125; @Test public void test3() throws Exception &#123; // serverSocketChannel ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); // 接收到一个socketChannel(客户端) SocketChannel socketChannel = serverSocketChannel.accept(); &#125;&#125; 5.3.3 Channel的常用方法 ServerSocketChannel： public static ServerSocketChannel open()：获取一个ServerSocketChannel public ServerSocket socket()：通过当前Channel获取Socket public ServerSocketChannel bind(SocketAddress local)：绑定一个地址，用于客户端（SocketChannel）来连接 public SocketChannel accept()：接收一个客户端（SocketChannel）；默认情况下，如果没有客户端来连接，那么accept会使得当前线程一直处于等待状态； public SelectableChannel configureBlocking(boolean block)：将当前Channel设置为非阻塞模式；默认为true（阻塞模式） public boolean isBlocking()：判断当前Channel是否为非阻塞模式；默认true（阻塞模式） SocketChannel： public static SocketChannel open() ：获取一个SocketChannel public Socket socket()：通过当前Channel获取Socket； public SocketChannel bind(SocketAddress local)：绑定一个地址，默认是本机地址，SocketChannel的该方法没有意义，因为SocketChannel是一个客户端，用于连接ServerSocketChannel，通过ServerSocketChannel可以获取客户端的地址，默认情况下SocketChannel为本机地址，并随机分配一个端口； public boolean connect(SocketAddress remote)：用于连接服务端 public int read(ByteBuffer dst)：读取Channel中的数据到Buffer中 public int write(ByteBuffer src)：将Buffer中的数据写入到Channel中； public SelectableChannel configureBlocking(boolean block)：将当前Channel设置为非阻塞模式；默认为true（阻塞模式） public boolean isBlocking()：判断当前Channel是否为非阻塞模式；默认true（阻塞模式） 1）基本读写 服务端： 12345678910111213141516171819202122232425262728293031323334353637383940package com.dfbz.channel.socketChannel和serverSocketChannel;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;/** * @author lscl * @version 1.0 * @intro: */public class Demo02_基本演示_服务端 &#123; public static void main(String[] args) throws Exception&#123; // 创建一个服务器 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); System.out.println(&quot;等待客户端连接....&quot;); // 绑定一个地址 serverSocketChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 9999)); /* 接收一个客户端(如果没有客户端来连接则会造成阻塞) 接收到了与客户端交互的Channel后,通过SocketChannel既可以向客户端写出数据,又可以读取来自客户端发送的数据 */ SocketChannel socketChannel = serverSocketChannel.accept(); System.out.println(&quot;客户端【&quot; + socketChannel.getRemoteAddress() + &quot;】连接成功成功....&quot;); // 准备一个Buffer ByteBuffer buffer = ByteBuffer.wrap(&quot;hello&quot;.getBytes()); // 往客户端写入数据 socketChannel.write(buffer); socketChannel.close(); serverSocketChannel.close(); &#125;&#125; 客户端： 123456789101112131415161718192021222324252627282930package com.dfbz.channel.socketChannel和serverSocketChannel;import org.junit.Test;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SocketChannel;/** * @author lscl * @version 1.0 * @intro: */public class Demo03_基本演示_客户端 &#123; @Test public void server() throws Exception &#123; SocketChannel socketChannel = SocketChannel.open(); // 连接到一个地址(如果该地址不存在,则默认情况下会阻塞,等到一定时间后抛出异常) socketChannel.connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 9999)); // 准备一个Buffer用于接收服务端的数据 ByteBuffer buffer = ByteBuffer.allocate(1024); // 读取服务端的数据,返回数据的长度 int len = socketChannel.read(buffer); System.out.println(&quot;数据长度: &quot; + len); System.out.println(new String(buffer.array(), 0, buffer.array().length)); &#125;&#125; 2）拷贝图片案例3）在线聊天案例仅限学习、交流使用！ QQ群名片 本文转自 https://blog.csdn.net/Bb15070047748/article/details/125438312，如有侵权，请联系删除。","tags":["nio"]},{"title":"五种IO模型：操作系统五种IO模型大全","path":"/2024/02/05/nio/五种IO模型：操作系统五种IO模型大全/","content":"文章目录 五种IO模型：操作系统五种IO模型大全 一、IO模型简介 1.1 操作系统的内存简介 1.1.1 操作系统的应用与内核 1.1.2 内核空间与用户空间 1.1.3 CPU指令等级 1.1.4 进程的内核态和用户态 1.2 IO的分类 1.2.1 网络IO和磁盘IO 1.2.1 同步IO和异步IO 1.2.2 阻塞IO和非阻塞IO 1.3 操作系统的五种IO模型 1.3.1 阻塞IO模型 1.3.2 非阻塞IO模型 1.3.3 复用IO模型 1）select(时间复杂度O(n)) 2）poll(时间复杂度O(n)) 3）epoll (时间复杂度O(1)) 4）IO复用模型小结 1.3.4 信号驱动IO模型 1.3.5 异步IO模型 五种IO模型：操作系统五种IO模型大全一、IO模型简介1.1 操作系统的内存简介1.1.1 操作系统的应用与内核现代计算机是由硬件和操作系统组成，我们的应用程序要操作硬件（如往磁盘上写数据），就需要先与内核交互，然后再由内核与硬件交互； 操作系统可以划分为：内核与应用两部分； 内核提供进程管理、内存管理、网络等底层功能，封装了与硬件交互的接口，通过系统调用提供给上层应用使用。 1.1.2 内核空间与用户空间现在操作系统都是采用虚拟地址空间，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间（内核空间），也有访问底层硬件设备的所有权限。 为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。内核空间是操作系统内核访问的区域，独立于普通的应用程序，是受保护的内存空间。用户空间是普通应用程序可访问的内存区域。 针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。 用户态的程序不能随意操作内核地址空间，即使用户的程序崩溃了，内核也不受影响。这样对操作系统具有一定的安全保护作用。 1.1.3 CPU指令等级其实早期操作系统是不区分内核空间和用户空间的，但是应用程序能访问任意内存空间，如果程序不稳定常常把系统搞崩溃，比如清除操作系统的内存数据。后来觉得让应用程序随便访问内存太危险了，就按照CPU 指令的重要程度对指令进行了分级； CPU指令分为四个级别：Ring0~Ring3，linux 只使用了 Ring0 和 Ring3 两个运行级别，进程运行Ring3级别的指令时运行在用户态，指令只访问用户空间，而运行在 Ring0级别时被称为运行在内核态，可以访问任意内存空间。 1.1.4 进程的内核态和用户态当进程运行在内核空间时，它就处于内核态；当进程运行在用户空间时，它就处于用户态。 那什么时候运行再内核空间什么时候运行再用户空间呢？ 当我们需要进行IO操作时，如读写硬盘文件、读写网卡数据等，进程需要切换到内核态，否则无法进行这样的操作，无论是从内核态切换到用户态，还是从用户态切换到内核态，都需要进行一次上下文的切换。一般情况下，应用不能直接操作内核空间的数据，需要把内核态的数据拷贝到用户空间才能操作。 比如我们 Java 中需要新建一个线程，调用 start() 方法时，基于Hotspot Linux 的JVM 源码实现，最终是调pthread_create系统方法来创建的线程，这里会从用户态切换到内核态完成系统资源的分配，线程的创建。 当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态） Tips：除了系统调用可以实现用户态到内核态的切换，软中断和硬中断也会切换用户态和内核态。 在内核态下：进程运行在内核地址空间中，此时 CPU 可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问。 在用户态下：进程运行在用户地址空间中，被执行的代码要受到 CPU 的很多检查，比如：进程只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址。 1.2 IO的分类通常用户进程中的一个完整IO分为两阶段：用户进程空间&lt;- -&gt;内核空间、**内核空间&lt;- -&gt;设备空间(磁盘、网络等)**。 1.2.1 网络IO和磁盘IOIO从读取数据的来源分为内存IO、 网络IO和磁盘IO三种，通常我们说的IO指的是后两者(因为内存IO的读写速度比网络IO和磁盘IO快的多)。 I&#x2F;O按照设备来分的话，分为两种：一种是网络I&#x2F;O，也就是通过网络进行数据的拉取和输出。一种是磁盘I&#x2F;O，主要是对磁盘进行读写工作。 网络IO：等待网络数据到达网卡→把网卡中的数据读取到内核缓冲区，然后从内核缓冲区复制数据到进程空间。 磁盘IO：把数据从磁盘中读取到内核缓冲区，然后从内核缓冲区复制数据到进程空间。 Tips：由于CPU和内存的速度远远高于外部设备（网卡，磁盘等）的速度，所以在IO编程中，存在速度严重不匹配的问题。 1.2.1 同步IO和异步IO 同步：A调用B，B的处理是同步的，在处理完之前他不会通知A，只有处理完之后才会明确的通知A。B在没有处理完A的请求时不能处理其他请求； 异步：A调用B，B的处理是异步的，B在接到请求后先告诉A我已经接到请求了，然后异步去处理，处理完之后通过回调等方式再通知A。B在处理A请求的同时，也可以接着处理其他人发送过来的请求； 同步和异步最大的区别就是被调用方的执行方式和返回时机。同步指的是被调用方做完事情之后再返回，异步指的是被调用方先返回，然后再做事情，做完之后再想办法通知调用方。 1.2.2 阻塞IO和非阻塞IO 阻塞：A调用B，A一直等着B的返回，别的事情什么也不干。 非阻塞：A调用B，A不用一直等着B的返回，先去忙别的事情了。 阻塞和非阻塞最大的区别就是在被调用方返回结果之前的这段时间内，调用方是否一直等待。阻塞指的是调用方一直等待别的事情什么都不做。非阻塞指的是调用方先去忙别的事情。 Tips：同步和异步强调的是被调用方（B–操作系统），阻塞和非阻塞强调的是调用方（A–应用程序）； 1.3 操作系统的五种IO模型1.3.1 阻塞IO模型阻塞IO就是当应用A发起读取数据申请时，在内核数据没有准备好之前，应用A会一直处于等待数据状态，直到内核把数据准备好了交给应用A才结束。 Tips：我们之前所学过的所有的套接字，默认都是阻塞方式。 优点：开发相对简单，在阻塞期间，用户线程被挂起，挂起期间不会占用CPU资源； 缺点： 1）连接利用率不高，内核如果没有响应数据，则该连接一直处于阻塞状态，占用连接资源 2）一个线程维护一个IO资源，当用大量并发请求时，需要创建等价的线程来处理请求，不适合用于高并发场景； 1.3.2 非阻塞IO模型非阻塞IO就是当应用A发起读取数据申请时，如果内核数据没有准备好会即刻告诉应用A（返回错误码等），不会让A在这里等待。一旦内核中的数据准备好了，并且又再次收到了A的请求，那么它马上就将数据拷贝到了用户线程，然后返回。 优点：每次发起IO调用去内核获取数据时，在内核等待数据的过程中可以立即返回，用户线程不会被阻塞，实时性较好； 缺点： 1）当用户线程A没有获取到数据时，不断轮询内核，查看是否有新的数据，占用大量CPU时间，效率不高； 2）和阻塞IO一样，一个线程维护一个IO资源，当用大量并发请求时，需要创建等价的线程来处理请求，不适合用于高并发场景； 1.3.3 复用IO模型如果在并发的环境下，可能会N个人向应用B发送消息，这种情况下我们的应用就必须创建多个线程去接收N个人发送过来的请求，每个请求都是一个独立的线程来处理；在并发量呈线性增长时，我们需要创建的线程数也随之而然的激增； 这种情况下应用B就需要创建N个线程去读取数据，同时又因为应用线程是不知道什么时候会有数据读取，为了保证消息能及时读取到，那么这些线程自己必须不断的向内核发送请求来读取数据（非阻塞式）； 这么多的线程不断请求数据，先不说服务器能不能扛得住这么多线程，就算扛得住那么很明显这种方式是不是太浪费资源了，线程是我们操作系统的宝贵资源，大量的线程用来去读取数据了，那么就意味着能做其它事情的线程就会少。 后来，有人就提出了一个思路，能不能提供一种方式，可以由一个线程监控多个网络请求（linux系统把所有网络请求以一个fd来标识，我们后面将称为fd即文件描述符），这样就可以只需要一个或几个线程就可以完成数据状态询问的操作，当有数据准备就绪之后再分配对应的线程去读取数据，这么做就可以节省出大量的线程资源出来，这个就是IO复用模型的思路。 IO复用模型的思路就是系统提供了一种函数（select&#x2F;poll&#x2F;epoll）可以同时监控多个fd的操作，有了这个函数后，应用线程通过调用select函数就可以同时监控多个fd，如果select监听的fd都没有可读数据，select调用进程会被阻塞；而只要有任何一个fd准备就绪了，select函数就会返回可读状态，这时询问线程再去通知处理数据的线程，对应的线程此时再发起请求去读取内核中准备好的数据； Tips：在IO复用模型下，允许单线程内处理多个IO请求； Linux中IO复用的实现方式主要有select，poll和epoll 1）select(时间复杂度O(n)) select：线性轮询扫描所有的fd，不管他们是否活跃，监听的IO最大连接数不能多于FD_ SIZE（32位操作系统1024，64位操作系统2048）。 Tips：select方式仅仅知道有I&#x2F;O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），用户线程只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。 2）poll(时间复杂度O(n)) **poll**：原理和select相似，poll底层需要分配一个pollfd结构数组，维护在内核中，它没有数量限制，但IO数量大，扫描线性性能下降。 3）epoll (时间复杂度O(1)) epoll ：用于代替poll和select，没有大小限制。epoll采用事件驱动代替了轮询，epoll会把哪个流发生了怎样的I&#x2F;O事件通知用户线程，所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时用户线程对这些流的操作都是有意义的。（复杂度降低到了O(1)），另外epoll模型采用mmap内存映射实现内核与用户空间的消息传递，减少用户态和内核态数据传输的开销，epoll模型在Linux2.6后内核支持。 select，poll，epoll都是IO多路复用的机制。I&#x2F;O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符准备就绪，能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写(一个个的处理)，也就是说这个读写过程是阻塞的，而异步I&#x2F;O则无需自己负责进行读写，异步I&#x2F;O的实现会负责把数据从内核拷贝到用户空间。 Tips：epoll跟select都能提供多路I&#x2F;O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现 4）IO复用模型小结 关于IO复用模型，下面这个例子可以很好的说明IO复用模型的原理： 某教室有10名学生和1名老师，这些学生上课会不停的提问，所以一个老师处理不了这么多的问题。那么学校为每个学生都配一名老师，也就是这个教室目前有10名老师。此后，只要有新的转校生，那么就会为这个学生专门分配一个老师，因为转校生也喜欢提问题。如果把以上例子中的学生比作客户端，那么老师就是负责进行数据交换的服务端。则该例子可以比作是多进程的方式。 后来有一天，来了一位具有超能力的老师，这位老师回答问题非常迅速，并且可以应对所有的问题。而这位老师采用的方式是学生提问前必须先举手，确认举手学生后在回答问题。则现在的情况就是IO复用。 IO复用模型的优点：系统不必创建和维护大量的线程，只使用一个或几个线程来监听select选择器的操作，而一个选择器可同时处理成千上万个连接，大大减少了系统的开销； IO复用模型的缺点：select本质上还是同步阻塞模式； 总结： 复用IO的基本思路就是通过select或poll、epoll来监控多fd ，来达到不必为每个fd创建一个对应的监控线程，从而减少线程资源创建的目的。复用IO模型的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。 1.3.4 信号驱动IO模型当进程发起一个IO操作，系统调用sigaction执行一个信号处理函数，该函数向内核注册一个信号处理函数（回调函数），然后进程返回，并且不阻塞当前进程；当内核数据准备好时，内核使用信号（SIGIO）通知应用线程调用recvfrom来读取数据（运行回调函数）。 信号驱动IO它也可以看成是一种异步非阻塞IO 我们说信号驱动IO模型是一种异步非阻塞IO模型，指的是用户线程去内核空间请求数据时，直接注册一个信号处理函数，然后用户线程返回（异步），而内核空间接收到请求后，开始处理（此时并不会阻塞，内核空间可以同时接收多个请求，注册多个信号处理函数）； 但是，等到内核空间读取到数据之后，应用线程需要将数据从内核空间拷贝到用户空间，**此时是用户线程是阻塞的；**也就是说：应用程序将数据从内核态拷贝到用户态的过程是阻塞等待的，这是和异步IO的本质区别； 1.3.5 异步IO模型在前面几种IO模型中，应用线程要获取数据总是先发送请求到内核，然后进行如下处理： 1）阻塞IO：应用线程等待内核响应数据，期间什么都不能做 2）非阻塞IO：应用线程立即响应，可以去处理其他事情，但需要不断轮询内核去获取数据 3）复用IO：采用IO复用机制，请求都先交给select函数，由应用线程调用select函数来轮询所有的请求，当有请求需要获取数据时，应用线程再去内核获取数据； 4）信号驱动IO：系统注册一个信号处理函数（回调函数），然后应用线程返回（不阻塞）；当内核中准备好数据后，应用线程需要把内核中的数据拷贝到用户空间，此时用户线程是阻塞的； 在以上4种IO模型中，每次要去读取数据时都是事先发送请求询问内核是否有可读数据，然后再发起真正的读取数据请求； 在异步IO模型中，应用只需要向内核发送一个请求，告诉内核它要读取数据后即刻返回；内核收到请求后会建立一个信号联系，当数据准备就绪，内核会主动把数据从内核复制到用户空间（而信号驱动是告诉应用程序何时可以开始拷贝数据），异步IO模型真正的做到了完完全全的非阻塞； Tips：异步IO模型和前面模型最大的区别是：前4个都是阻塞的，需要自己把用户准备好的数据，去内核拷贝到用户空间。而全异步不同，用户线程完全不需要关心实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据，它是最理想的模型。 仅限学习、交流使用！ QQ群名片 本文转自 https://blog.csdn.net/Bb15070047748/article/details/124699009，如有侵权，请联系删除。","tags":["nio"]},{"title":"线程池","path":"/2023/08/05/线程池/","content":"一、创建@Async线程池创建一个配置类 配置线程池参数注入 spring 使用时加入线程池名称 123456789101112131415161718@Configurationpublic class AsyncConfig &#123; @Bean(name = &quot;taskExecutor&quot;) public TaskExecutor taskExecutor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(10); executor.setMaxPoolSize(100); executor.setQueueCapacity(200); executor.setThreadNamePrefix(&quot;MyExecutor-&quot;); executor.initialize(); return executor; &#125;&#125;@Async(&quot;taskExecutor&quot;)public void doSomething() &#123; // do something here&#125; 二、Executors类创建四种常用线程池参考 https://blog.csdn.net/ThinkWon/article/details/102541990 Java里面线程池的顶级接口是Executor，Executor并不是一个线程 池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService 比较重要的几个类： 类&#x2F;接口 描述 ExecutorService 真正的线程池接口 ScheduledExecutorService 能和Timer&#x2F;TimerTask类似，解决那些需要任务重复执行的问题 ThreadPoolExecutor ExecutorService的默认实现 ScheduledThreadPoolExecutor 继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现 Java通过Executors工厂类提供四种线程池，分别为： 类名 描述 场景 源码 newCachedThreadPool 可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，否则新建线程。（线程最大并发数不可控制） 用于并发执行大量短期的小任务，或者是负载较轻的服务器。 newFixedThreadPool 固定大小的线程池，可控制线程最大并发数，超出的线程会在队列中等待。 用于负载比较重的服务器，为了资源的合理利用，需要限制当前线程数量。 newScheduledThreadPool 定时线程池，支持定时及周期性任务执行。 用于需要多个后台线程执行周期任务，同时需要限制线程数量的场景。 newSingleThreadExecutor 单线程的线程池，保证任务按照指定顺序(FIFO, LIFO, 优先级)执行 用于串行执行任务的场景，每个任务必须按顺序执行，不需要并发执行。 Executors和ThreaPoolExecutor创建线程池的区别Executors 各个方法的弊端：newFixedThreadPool 和 newSingleThreadExecutor:主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。newCachedThreadPool 和 newScheduledThreadPool:主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。ThreaPoolExecutor:创建线程池方式只有一种，就是走它的构造函数，参数自己指定,灵活 两种提交任务的方法execute提交不需要返回值的任务 12345678ExecutorService executor = Executors.newCachedThreadPool();executor.execute(new Runnable() &#123; @Override public void run() &#123; //do something &#125;&#125;); execute(执行)() 的参数是一个 Runnable，也没有返回值。因此提交后无法判断该任务是否被线程池执行成功。 submit提交需要返回值的任务 1234&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Future&lt;?&gt; submit(Runnable task); submit(提交)() 有三种重载，参数可以是 Callable 也可以是 Runnable。同时它会返回一个 Funture 对象，通过它我们可以判断任务是否执行成功。获得执行结果调用 Future(未来).get() 方法，这个方法会阻塞当前线程直到任务完成。 提交一个 Callable 任务时，需要使用 FutureTask 包一层： 12345678910111213141516FutureTask futureTask = new FutureTask(new Callable&lt;String&gt;() &#123; //创建 Callable 任务 @Override public String call() throws Exception &#123; String result = &quot;&quot;; //do something return result; &#125;&#125;);Future&lt;?&gt; submit = executor.submit(futureTask); //提交到线程池try &#123; Object result = submit.get(); //获取结果&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; catch (ExecutionException e) &#123; e.printStackTrace();&#125;","tags":["Java","线程池"]},{"title":"Spring 整合 Redis Stream 做消息队列","path":"/2023/08/05/Spring-整合-Redis-Stream-做消息队列/","content":"参考 https://www.jianshu.com/p/b95a265f838a为什么选redis stream1 不希望引入其它中间件2 业务规模目前不大 ，可以试水3 redis stream 比kafka还快？ 核心逻辑1.自定义注解 12345678@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface RedisStreamMqListen &#123;String value(); Class type();&#125; 2.监听器注册和发送方法封装 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283@Slf4jpublic class RedisStreamMqServiceImpl implements RedisStreamMqService &#123;private final long dataCenterId = getDataCenterId();private final RedisTemplate&lt;String, String&gt; redisTemplate;/** * 最大长度 */long maxLen;private String group;public RedisStreamMqServiceImpl(RedisTemplate&lt;String, String&gt; redisTemplate, String group, Long maxLen) &#123; this.redisTemplate = redisTemplate; this.group = group; this.maxLen = maxLen;&#125;private static Long getDataCenterId() &#123; try &#123; String hostName = Inet4Address.getLocalHost().getHostName(); int[] ints = StringUtils.toCodePoints(hostName); int sums = 0; for (int b : ints) &#123; sums += b; &#125; return (long) (sums % 32); &#125; catch (UnknownHostException e) &#123; // 如果获取失败，则使用随机数备用 return RandomUtils.nextLong(0, 31); &#125;&#125;public void listener(String event, Class type, StreamListener streamListener) &#123; createGroup(event); startSubscription(event, type, streamListener);&#125;public &lt;V&gt; void coverSend(String event, V val) &#123; ObjectRecord&lt;String, V&gt; record = StreamRecords.newRecord().ofObject(val).withId(RecordId.autoGenerate()) .withStreamKey(event); redisTemplate.opsForStream().add(record); redisTemplate.opsForStream().trim(event, maxLen, true); log.info(&quot;event &#123;&#125; send content &#123;&#125;&quot;, event, StringUtils.abbreviate(val.toString().trim(), 100));&#125;private void startSubscription(String event, Class type, StreamListener streamListener) &#123; RedisConnectionFactory redisConnectionFactory = redisTemplate.getConnectionFactory(); StreamMessageListenerContainer.StreamMessageListenerContainerOptions options = StreamMessageListenerContainer.StreamMessageListenerContainerOptions .builder().batchSize(5) // 设置批次大小为 5 .pollTimeout(Duration.ofSeconds(1)).targetType(type).build(); StreamMessageListenerContainer listenerContainer = StreamMessageListenerContainer.create(redisConnectionFactory, options); // redisTemplate 会自动加上前缀,所有在监听的时候也要加上 event = &quot;frl-stream:&quot; + event; listenerContainer.receiveAutoAck(Consumer.from(group, group + dataCenterId), StreamOffset.create(event, ReadOffset.lastConsumed()), streamListener); listenerContainer.start();&#125;private void createGroup(String event) &#123; try &#123; redisTemplate.opsForStream().createGroup(event, group); &#125; catch (RedisSystemException e) &#123; if (e.getRootCause() instanceof RedisBusyException) &#123; log.info(&quot;STREAM - Redis group already exists, skipping Redis group creation: &#123;&#125;&quot;, group); &#125; else if (e.getRootCause() instanceof RedisCommandExecutionException) &#123; log.info(&quot;STREAM - Stream does not yet exist, creating empty stream: &#123;&#125;&quot;, event); boolean streamExists = redisTemplate.hasKey(event); if (!streamExists) &#123; redisTemplate.opsForStream().add(event, Collections.singletonMap(&quot;&quot;, &quot;&quot;)); &#125; redisTemplate.opsForStream().createGroup(event, group); &#125; else &#123; throw e; &#125; &#125;&#125;&#125; 其中 核心逻辑为监听方法 1234567891011121314151617181920212223242526272829303132333435363738394041public void listener(String event, Class type, StreamListener streamListener) &#123;createGroup(event);startSubscription(event, type, streamListener);&#125;private void createGroup(String event) &#123;try &#123;redisTemplate.opsForStream().createGroup(event, group);&#125; catch (RedisSystemException e) &#123;if (e.getRootCause() instanceof RedisBusyException) &#123;log.info(&quot;STREAM - Redis group already exists, skipping Redis group creation: &#123;&#125;&quot;, group);&#125; else if (e.getRootCause() instanceof RedisCommandExecutionException) &#123;log.info(&quot;STREAM - Stream does not yet exist, creating empty stream: &#123;&#125;&quot;, event);boolean streamExists = redisTemplate.hasKey(event);if (!streamExists) &#123;redisTemplate.opsForStream().add(event, Collections.singletonMap(&quot;&quot;, &quot;&quot;));&#125;redisTemplate.opsForStream().createGroup(event, group);&#125; else &#123;throw e;&#125;&#125;&#125;private void startSubscription(String event, Class type, StreamListener streamListener) &#123;RedisConnectionFactory redisConnectionFactory = redisTemplate.getConnectionFactory(); StreamMessageListenerContainer.StreamMessageListenerContainerOptions options = StreamMessageListenerContainer.StreamMessageListenerContainerOptions .builder().batchSize(5) // 设置批次大小为 5 .pollTimeout(Duration.ofSeconds(1)).targetType(type).build(); StreamMessageListenerContainer listenerContainer = StreamMessageListenerContainer.create(redisConnectionFactory, options); // redisTemplate 会自动加上前缀,所有在监听的时候也要加上 event = &quot;frl-stream:&quot; + event; listenerContainer.receiveAutoAck(Consumer.from(group, group + dataCenterId), StreamOffset.create(event, ReadOffset.lastConsumed()), streamListener); listenerContainer.start();&#125; 核心逻辑 通过 listenerContainer.receiveAutoAck(…) 注册了一个消息监听器，该监听器实现了 StreamListener 接口，定义了 onMessage 方法用于处理接收到的消息。 调用 listenerContainer.start() 启动消息监听。 当 Redis Stream 中有消息到达时，StreamMessageListenerContainer 会调用注册的 StreamListener 的 onMessage 方法，并将消息作为参数传递给这个方法。 在 onMessage 方法中，编写逻辑来处理接收到的消息 这里 event 做了特殊操作，是因为在redisTemplate中设置了 key 的前缀，是用redisTemplate创建的队列，而这里是通过listenerContainer添加监听，所有为了匹配上 key 添加这个操作 项目启动后自动对注解添加监听操作 public class ListenAnnotation implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123; private static final Logger log = LoggerFactory.getLogger(ListenAnnotation.class); final RedisStreamMqService redisStreamMqService; public ListenAnnotation(RedisStreamMqService redisStreamMqService) &#123; this.redisStreamMqService = redisStreamMqService; &#125; @Override public void onApplicationEvent(ContextRefreshedEvent event) &#123; if (event.getApplicationContext().getParent() == null) &#123; Map&lt;String, Object&gt; beans = event.getApplicationContext().getBeansWithAnnotation(RedisStreamMqListen.class); for (Object bean : beans.values()) &#123; RedisStreamMqListen ca = bean.getClass().getAnnotation(RedisStreamMqListen.class); redisStreamMqService.listener(ca.value(), ca.type(), (StreamListener) bean); log.info(&quot;event &#123;&#125; start listen&quot;, ca.value()); &#125; &#125; &#125; &#125; 在应用启动过程中，ListenAnnotation会监听 ContextRefreshedEvent 事件，然后扫描应用上下文中的所有 Bean，查找标记了 @RedisStreamMqListen 注解的 Bean，然后将它们注册到RedisStreamMqStartService 中进行消息监听。event.getApplicationContext().getParent() &#x3D;&#x3D; null判断是否为根上下文，确保注册方法只执行一次3.实现监听类,使用 @Component @Slf4j @RedisStreamMqListen(value = &quot;briefReportListener&quot;, type = AnalyzeToolDTO.class) public class BriefReportListener implements StreamListener&lt;String, ObjectRecord&lt;String, AnalyzeToolDTO&gt;&gt; &#123; @Resource private BriefReportServiceImpl briefReportService; @SneakyThrows @Override public void onMessage(ObjectRecord&lt;String, AnalyzeToolDTO&gt; message) &#123; ... &#125; }","tags":["Spring","Redis"]},{"title":"oauth","path":"/2023/01/08/oauth/","content":"2认证和授权的概念​\t认证即解决 我是谁 ​\t授权即解决 我能做什么 ​ 1234567891011@EnableWebSecurity(debug = true)public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; //检查请求是否认证 http.authorizeRequests(req -&gt; req.antMatchers(&quot;/api/**&quot;).authenticated()); //检查请求是否有权限 http.authorizeRequests(req -&gt; req.antMatchers(&quot;/api/**&quot;).hasRole(&quot;ADMIN&quot;)); &#125;&#125; 过滤器和过滤器链​ 任何Spring Web 应用本质上都是一个servlet，Security Filter 在HTTP请求到达Controller之前会过滤每一个请求。 使用过滤器链的好处： 职责单一、将负责逻辑简单化。 HTTP 请求的结构 12POST localhost:8080/api/user/hello2?name=安慰Authorization: Basic user 15afce2c-a151-4507-800a-9805ca227506 HTTP 响应和 HTTP Basic Auth 客户端请求服务端，服务端返回未授权，同时headle 里返回指定的认证方式，客户端收到响应后让用户填写信息发送服务端，服务端认证通过后返回通过状态码 安全配置security 标准传统写法 and() 会返回一个HttpSecurity 继续配置 也可以使用函数式写法 定制登录页​ 使用传统模板引擎 加入thymeleaf webjars 依赖 12345678dependencies &#123; implementation &#x27;org.springframework.boot:spring-boot-starter-security&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-web&#x27; implementation &#x27;org.projectlombok:lombok&#x27; implementation(&#x27;org.springframework.boot:spring-boot-starter-thymeleaf&#x27;) implementation(&#x27;org.webjars:bootstrap:4.5.3&#x27;) implementation(&#x27;org.webjars:webjars-locator-core&#x27;)&#125; ​ 配置SecurityConfig 1234567891011121314151617181920212223242526272829303132@EnableWebSecurity(debug = true)@Slf4jpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http //配置需要拦截的请求 req.anyRequest() 如何页面都需要认证 .authorizeRequests(req -&gt; req.antMatchers(&quot;/api/**&quot;).authenticated()) //配置登录 使用全部过滤需要加.permitAll() .formLogin(from -&gt; from.loginPage(&quot;/login&quot;)) .csrf(Customizer.withDefaults()) ; &#125; /** * 静态资源不拦截 不启动安全拦截 * * @param web * @throws Exception */ @Override public void configure(WebSecurity web) throws Exception &#123; web.ignoring().antMatchers(&quot;/public/**&quot;, &quot;/css/**&quot;, &quot;/js/**&quot;, &quot;/images/**&quot;) //常用静态资源地址 .requestMatchers(PathRequest.toStaticResources().atCommonLocations()); &#125;&#125; ​ 配置mvcConfig 123456789101112131415161718@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations(&quot;/webjars/**&quot;) .resourceChain(false); // 不缓存 registry.setOrder(1) ; &#125; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry .addViewController(&quot;/login&quot;)//url .setViewName(&quot;login&quot;);//视图html名称 &#125;&#125; 即指定了自己的登录页面 登录成功及失败的处理 登录成功后返回json 由前端判断路由 123456789101112131415161718192021222324.formLogin(from -&gt; from.loginPage(&quot;/login&quot;) //传入AuthenticationSuccessHandler 类中的onAuthenticationSuccess方法，可以用函数式接口 //认证成功后的处理 .successHandler(getAuthenticationSuccessHandler()) //认证失败的处理器 .failureHandler(getAuthenticationFailureHandler()) .permitAll()) private static AuthenticationSuccessHandler getAuthenticationSuccessHandler() &#123; return (req, resp, auth) -&gt; &#123; resp.setStatus(HttpStatus.OK.value()); resp.setContentType(&quot;application/json;charset=utf-8&quot;); resp.getWriter().write( new ObjectMapper().writeValueAsString(auth)); &#125;; &#125; private static AuthenticationFailureHandler getAuthenticationFailureHandler() &#123; return (req, resp, e) -&gt; &#123; resp.setStatus(HttpStatus.UNAUTHORIZED.value()); resp.setContentType(&quot;application/json;charset=utf-8&quot;); resp.getWriter().write(new ObjectMapper().writeValueAsString(e.getMessage())); &#125;; &#125; spring 自带的登录成功处理器 -传统项目用到 前后端分离的不适合 12345678910111213141516171819202122232425262728293031323334/** * Calls the parent class &#123;@code handle()&#125; method to forward or redirect to the target * URL, and then calls &#123;@code clearAuthenticationAttributes()&#125; to remove any leftover * session data. */ public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; handle(request, response, authentication); //清理存在session 中的信息 删除在身份验证过程中可能存储在会话中的临时身份验证相关数据。 clearAuthenticationAttributes(request); &#125; /** * Invokes the configured &#123;@code RedirectStrategy&#125; with the URL returned by the * &#123;@code determineTargetUrl&#125; method. * &lt;p&gt; * The redirect will not be performed if the response has already been committed. */ protected void handle(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; //记录访问的目标url String targetUrl = determineTargetUrl(request, response, authentication); if (response.isCommitted()) &#123; logger.debug(&quot;Response has already been committed. Unable to redirect to &quot; + targetUrl); return; &#125; //认证通过后重定向到目标url redirectStrategy.sendRedirect(request, response, targetUrl); &#125; 自定义 FilterSpring 默认用来处理登录的过滤器 UsernamePasswordAuthenticationFilter 12345678910111213141516171819202122232425262728public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; if (postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) &#123; throw new AuthenticationServiceException( &quot;Authentication method not supported: &quot; + request.getMethod()); &#125; String username = obtainUsername(request); String password = obtainPassword(request); if (username == null) &#123; username = &quot;&quot;; &#125; if (password == null) &#123; password = &quot;&quot;; &#125; username = username.trim(); //构造一个安全对象 UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken( username, password); // Allow subclasses to set the &quot;details&quot; property setDetails(request, authRequest); //认证处理最终机制 return this.getAuthenticationManager().authenticate(authRequest); &#125; 自己新建一个模仿默认过滤器写一个RestAuthenticationFilter 1234567891011121314151617181920212223242526272829//@RequiredArgsConstructor//将flnal 修饰的私有成员变量放到构造函数中public class RestAuthenticationFilter extends UsernamePasswordAuthenticationFilter &#123; private ObjectMapper objectMapper; public RestAuthenticationFilter(ObjectMapper objectMapper) &#123; this.objectMapper = objectMapper; &#125; @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; UsernamePasswordAuthenticationToken authRequest; try &#123; ServletInputStream inputStream = request.getInputStream(); JsonNode jsonNode = objectMapper.readTree(inputStream); String username = jsonNode.get(&quot;username&quot;).textValue(); String password = jsonNode.get(&quot;password&quot;).textValue(); authRequest= new UsernamePasswordAuthenticationToken(username, password); setDetails(request, authRequest); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new BadCredentialsException(&quot;Invalid username or password&quot;); &#125; return this.getAuthenticationManager().authenticate(authRequest); &#125;&#125; 然后在securityConfig中把自定义filter 加入过滤器链中 选择addFilterAt 替代默认过滤器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Override protected void configure(HttpSecurity http) throws Exception &#123; http //配置需要拦截的请求 .authorizeRequests(req -&gt; req //不需要拦截的路径 .antMatchers(&quot;/authorize/**&quot;).permitAll() //配置需要权限的路径 .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;) .antMatchers(&quot;/api/**&quot;).hasRole(&quot;USER&quot;) .anyRequest().authenticated()) //将自定义过滤器加入 .addFilterAt(restAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class) /*将原来的登录配置去掉*/ //配置登录// .formLogin(from -&gt; from.loginPage(&quot;/login&quot;)// //传入AuthenticationSuccessHandler 类中的onAuthenticationSuccess方法，可以用函数式接口// //认证成功后的处理// .successHandler(getAuthenticationSuccessHandler())// //认证失败的处理器// .failureHandler(getAuthenticationFailureHandler())// .permitAll())// .logout(logout -&gt; logout.logoutUrl(&quot;/perform_logout&quot;)// .logoutSuccessHandler((request, response, authentication) -&gt; &#123;// response.setStatus(HttpStatus.OK.value());// response.setContentType(&quot;application/json;charset=UTF-8&quot;);// response.getWriter().write(new ObjectMapper().writeValueAsString(&quot;注销成功&quot;));// &#125;)// .permitAll())// .csrf(csrf-&gt;csrf.disable()) ; &#125;/*配置自定义过滤器设置*/private RestAuthenticationFilter restAuthenticationFilter () throws Exception &#123; RestAuthenticationFilter filter = new RestAuthenticationFilter(objectMapper); //设置认证成功的处理方法 filter.setAuthenticationSuccessHandler(getAuthenticationSuccessHandler()); filter.setAuthenticationFailureHandler(getAuthenticationFailureHandler()); //设置AuthenticationManager 分类的方法 filter.setAuthenticationManager(authenticationManager()); //设置请求路径 filter.setFilterProcessesUrl(&quot;/authorize/login&quot;); return filter; &#125; 思路：先去看spring默认的过滤器怎么写的，然后模仿他。 33-1 密码进化史 哈希可用彩虹表 比对 得出原文 加盐：每次加密会随机生成一个盐值，存放在系统中，使用盐值+原文 哈希加密。 加大了密码复杂度后，响应时间会加长。 3-2 密码编码器常用的有 BCryptPasswordEncoder 使用多编码格式时，在存储密文时会在前面加上他的加密方式标识，设置时的key。{bcrypt}*** 密码升级的思路： 用户登录时拿到 明文密码，认证通过后 使用新的加密方式得到密文 替换 原有密文 3-3 验证注解和自定义验证注解 JSR-380验证框架implementation(‘org.springframework.boot:spring-boot-starter-validation’) implementation(‘org.springframework.boot:spring-boot-starter-validation’) 3-4密码的验证规则和自定义注解和验证器 密码校验创建一个校验注解 123456789101112131415161718192021222324252627package com.li.springsecurity.annotation;import com.li.springsecurity.validation.PasswordConstraintValidator;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import javax.validation.Constraint;import javax.validation.Payload;@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Constraint(validatedBy = &#123;PasswordConstraintValidator.class&#125;)@Documentedpublic @interface ValidPassword &#123; String message() default &quot;Invalid password&quot;; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; 创建一个类实现密码验证ConstraintValidator接口 ： 接口使用了泛型，需要指定两个参数，第一个自定义注解类，第二个为需要校验的数据类型。 实现接口后要override两个方法，分别为initialize方法和isValid方法。其中initialize为初始化方法，可以在里面做一些初始化操作，isValid方法就是最终需要的校验方法。可以在该方法中实现具体的校验步骤。 本方法使用了passay 提供的校验方式。 123456789101112131415161718192021222324252627public class PasswordConstraintValidator implements ConstraintValidator&lt;ValidPassword,String&gt; &#123; @Override public boolean isValid(String password, ConstraintValidatorContext constraintValidatorContext) &#123; val validator = new PasswordValidator(Arrays.asList( new LengthRule(8, 30), //至少一个大写字母 new CharacterRule(EnglishCharacterData.UpperCase, 1), //至少一个小写字母 new CharacterRule(EnglishCharacterData.LowerCase, 1), //至少一个数字字符 new CharacterRule(EnglishCharacterData.Special, 1), //至少一个特殊字符 new CharacterRule(EnglishCharacterData.Digit, 1), new WhitespaceRule() )); //验证密码 val result = validator.validate(new PasswordData(password)); return result.isValid(); &#125; @Override public void initialize(ValidPassword constraintAnnotation) &#123; ConstraintValidator.super.initialize(constraintAnnotation); &#125;&#125; ​\t使用时加上该注解即可 123@NotNull @ValidPassword private String password; 多字段联合校验同样先创建一个注解 作用于类上 123456789101112@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Constraint(validatedBy = &#123;PasswordMatchValidator.class&#125;)@Documentedpublic @interface PasswordMatch &#123; String message() default &quot;password not matched&quot;; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; 创建一个验证类 ​ 这里需要实现的泛型写需要校验的类 ​ 在isValid中进行多字段校验 123456789101112public class PasswordMatchValidator implements ConstraintValidator&lt;PasswordMatch, UserDTO&gt; &#123; @Override public void initialize(PasswordMatch constraintAnnotation) &#123; ConstraintValidator.super.initialize(constraintAnnotation); &#125; @Override public boolean isValid(UserDTO userDTO, ConstraintValidatorContext constraintValidatorContext) &#123; //两次密码是否一致 val result = userDTO.getPassword().equals(userDTO.getMatchingPassword()); return result; &#125; 3-5 passay 异常消息的国际化​\t在之前的异常返回信息中都是英文 用passay的中英文字典 处理 在WebMvcConfig中配置messageResolver 在passay PasswordValidator() 构造器中引入 springMessageResolver消息解析器。 将原有错误信息禁用，使用新的错误信息 配置 添加中文和英文的国际化消息内容 -https://blog.csdn.net/weixin_38657051/article/details/115221338 valid 消息国际化 在mvcconfig中再加一个 bean ​ 3-6 异常统一处理主要用到了 problem 的功能 引入 problem 依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.zalando&lt;/groupId&gt; &lt;artifactId&gt;problem-spring-web&lt;/artifactId&gt; &lt;version&gt;0.26.1&lt;/version&gt;&lt;/dependency&gt; 创建ExcepptionHandler 1234567891011@ControllerAdvice public class ExceptionHandler implements ProblemHandling &#123; /** * 是否将堆栈中的错误信息返回 */ @Override public boolean isCausalChainsEnabled() &#123; return true; &#125; &#125; 创建SecurityExceptionHandler 123public class SecurityExceptionHandler implements SecurityAdviceTrait&#123;&#125; 配置异常替换 https://blog.csdn.net/weixin_38657051/article/details/115221684 3-7 多种安全配置共存 既能实现form表单登录，同时也支持api的rest请求的登录。 再写一个针对传统页面登录的配置 12345678910111213141516171819202122232425@Configuration@Slf4j@Order(100)public class LoginSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests(req -&gt; req.anyRequest().authenticated())//授权请求控制 .formLogin(form -&gt; form.loginPage(&quot;/login&quot;) .usernameParameter(&quot;username1&quot;) .defaultSuccessUrl(&quot;/index&quot;) .permitAll()) .logout(logout -&gt; logout.logoutUrl(&quot;/perform_logout&quot;)) .rememberMe(rememberMe-&gt; rememberMe.tokenValiditySeconds(60*60)); &#125; @Override public void configure(WebSecurity web) throws Exception &#123; web.ignoring().mvcMatchers(&quot;/webjars/**&quot;, &quot;/public/**&quot;) //常用静态资源地址 .requestMatchers(PathRequest.toStaticResources().atCommonLocations()); &#125;&#125; 写法和普通配置一致，然后在其中配置针对表单登录显示的处理，多配置类共存的情况下，需要设置@Order注解，用来顺序加载Bean。否则会冲突。 4 4-1 核心组件 - SecurityContext SecurityContextHolder Authentication securityContext 存储的 为 Authentication 接口 Principal ： 个人信息 Object 可以放任何信息 不一定是一个人 可以是程序 credentials ： 可以存储各种密码信息 如 人脸识别 数据信息 包含各种token 实践一下 写一个获取用户权限信息的接口 由于get不能携带body，开启httpBasic 使其能携带认证头 测试一下 在Spring中 被Spring管理的 可以直接注入用户信息 同样拿到了用户信息 4-2 UserDetails、UserDetailsService和jdbcAuthenticationUserDetails 是通常意义上的用户 UserDetailsService 用于调取用户信息的服务 把用户信息提取出来 形成UserDetails UserDetails 是一个接口 高可拓展性 想要定制化 可以实现这些接口 真正的认证服务在 AuthenticationManager 中配置 只有一个方法，加载用户信息 添加数据库依赖 配置 使用h2内存数据库 可以设置h2 模式mysql 123456789101112131415161718192021222324&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; datasource: driver-class-name: org.h2.Driver password: &quot;&quot; url: jdbc:h2:mem:test;MODE=MySQL;DATABASE_TO_LOWER=TRUE username: sa h2: console: enabled: true path: /h2-console settings: trace: false web-allow-others: false 添加内建数据库支持 配置好后生成了设置的两个用户 4-3 定制化数据库设置表查询语句 4-4 深度定制化上 - 实现 UserDetails 和 GrantedAuthority 创建user类 和 role 类 实现UserDetails 并实现其方法 12345678910111213141516171819202122232425262728293031323334353637383940414243@Entity@Table(name = &quot;users&quot;)public class User implements UserDetails, Serializable &#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(length = 50,unique = true,nullable = false) private String username; @Column(name =&quot;password_hash&quot;,length = 80,nullable = false) private String password; @Column(length = 255,unique = true,nullable = false) private String email; @Column(length = 50) private String realName; @Column(name = &quot;enabled&quot;,nullable = false) private boolean enabled; @Column(name = &quot;account_non_expired&quot;,nullable = false) private boolean accountNonExpired; @Column(name = &quot;account_non_locked&quot;,nullable = false) private boolean accountNonLocked; @Column(name = &quot;credentials_non_expired&quot;,nullable = false) private boolean credentialsNonExpired; @ManyToMany @Fetch(FetchMode.JOIN) @JoinTable(name = &quot;user_role&quot; ,joinColumns =&#123; @JoinColumn(name = &quot;user_id&quot;,referencedColumnName = &quot;id&quot;)&#125; ,inverseJoinColumns =&#123; @JoinColumn(name = &quot;role_id&quot;,referencedColumnName = &quot;id&quot;)&#125;) private Set&lt;Role&gt; authorities; Role 实现 GrantedAuthority 接口 1234567891011121314151617181920212223242526@Data@Entity@Table(name = &quot;roles&quot;)public class Role implements GrantedAuthority , Serializable &#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = &quot;role_name&quot;,length = 50,unique = true,nullable = false) private String authority; @ManyToMany(mappedBy = &quot;authorities&quot;) private Collection&lt;User&gt; users; public Collection&lt;User&gt; getUsers() &#123; return users; &#125; public void setUsers(Collection&lt;User&gt; users) &#123; this.users = users; &#125;&#125; 在security config 中 配置自己的用户、权限 查找sql 1234567891011121314151617181920@Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.jdbcAuthentication() //设置默认的schema .withDefaultSchema() //设置数据源 .dataSource(dataSource) .usersByUsernameQuery(&quot;select username,password,enabled from users where username=?&quot;) .authoritiesByUsernameQuery(&quot;select username,authority from authorities where username=?&quot;) .withUser(&quot;user&quot;) .password(&quot;12345678&quot;) .roles(&quot;USER&quot;, &quot;ADMIN&quot;) .and() .withUser(&quot;old_user&quot;) .password(&quot;123456&quot;) .roles(&quot;USER&quot;) ; &#125; 4-5 深度定制化下 - UserDetailsService 和 UserDetailsPasswordService创建 UserDetailsServiceImpl 实现 UserDetaiilsService 123456789101112@Service@RequiredArgsConstructorpublic class UserDetailsServiceImpl implements UserDetailsService &#123; private final UserRepo userRepo; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; return userRepo.findByUsername(username) .orElseThrow(() -&gt; new UsernameNotFoundException(&quot;User not found&quot;)); &#125;&#125; 创建UserDetailsPasswordServiceImpl 实现 UserDetailsPasswordService 12345678910111213141516@Service@RequiredArgsConstructorpublic class UserDetailsPasswordServiceImpl implements UserDetailsPasswordService &#123; private final UserRepo userRepo; //用于密码升级 @Override public UserDetails updatePassword(UserDetails user, String newPassword) &#123; return userRepo.findByUsername(user.getUsername()) .map(u -&gt; (UserDetails)userRepo.save(u.withPassword(newPassword)) ) .orElse(user); &#125;&#125; dao 层代码 12345678910111213@Repositorypublic interface UserRepo extends JpaRepository&lt;User,Long&gt;&#123; Optional&lt;User&gt; findByUsername(String username);&#125;@Repositorypublic interface RoleRepo extends JpaRepository&lt;Role, Long&gt; &#123;&#125; 用 Optional作为返回值 能够方便的判空并进行处理 实体类使用@ With 能够修改属性的值 并返回一个新的对象https://www.jianshu.com/p/6660142f70c7 4-6 环境和环境变量 环境变量可以把敏感信息 隔离出来，不写在yml中 开发与运维隔离 不同环境可以设置不同的yml 并用 123spring:\tprofiles: active: dev 标注这个文件是哪个环境 在application.yml 或者环境 中指定使用哪个配置 4-7 自动化测试 12345678910111213141516171819202122232425@SpringBootTest public class SecurityRestAPIIntTests &#123; @Autowired private WebApplicationContext context; private MockMvc mockMvc; @BeforeEach public void setup() &#123; mockMvc = MockMvcBuilders.webAppContextSetup(context) //应用安全配置 .apply(springSecurity()) .build(); &#125; //提供一个虚拟用户 @WithMockUser(username = &quot;user&quot;, password = &quot;password&quot;, roles = &quot;USER&quot;) @Test public void givenNoToken_whenGetSecureRequest_thenUnauthorized() throws Exception &#123; mockMvc.perform(get(&quot;/api/gr&quot;)) .andExpect(status().isOk()); &#125; &#125; 5 深入了解springSecurity 认证过程 5-1 认证流程和源码解析 AuthenticationManager中可以有多个AuthenticationProvider ，Provider 是认证机制，支持多种方式 如 数据库密码严重 通过http去其他服务认证 只要一个 provider 认证成功 会将用户信息拿到 构建一个UserDetails https://blog.51cto.com/u_15072920/4180591 密码升级 5-2 LDAP 配置和多 AuthenticationProvider 共存日常接触场景不多 用户信息不止存储于sql数据库中 security认证流程很复杂 是为了适配多种认证方式 https://www.cnblogs.com/wilburxu/p/9174353.html ldap是树状结构 配置： 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-ldap&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.ldap&lt;/groupId&gt; &lt;artifactId&gt;spring-ldap-core&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-ldap&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.unboundid&lt;/groupId&gt; &lt;artifactId&gt;unboundid-ldapsdk&lt;/artifactId&gt;&lt;/dependency&gt; 12345678spring:\tldap: base: dc=imooc,dc=com embedded: base-dn: dc=imooc,dc=com ldif: classpath:test-ldap-server.ldif port: 8389 urls: ldap://localhost:8389/ 创建LDAPUser模型 实现UserDetails 1234567891011121314151617181920212223242526272829303132333435363738394041@Builder @Data @AllArgsConstructor @NoArgsConstructor @Entry(objectClasses = &#123;&quot;inetOrgPerson&quot;, &quot;organizationalPerson&quot;, &quot;person&quot;, &quot;top&quot;&#125;) public final class LDAPUser implements UserDetails &#123; @Id @JsonIgnore private Name id; @Attribute(name = &quot;uid&quot;) private String username; @Attribute(name = &quot;userPassword&quot;) private String password; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return Collections.singletonList(new SimpleGrantedAuthority(&quot;ROLE_USER&quot;)); &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125; &#125; ORM层 12345678910111213141516package com.imooc.uaa.security.auth.ldap;import org.springframework.data.ldap.repository.LdapRepository;import org.springframework.stereotype.Repository;import java.util.List;import java.util.Optional;@Repositorypublic interface LDAPUserRepo extends LdapRepository&lt;LDAPUser&gt; &#123; Optional&lt;LDAPUser&gt; findByUsername(String username); Optional&lt;LDAPUser&gt; findByUsernameAndPassword(String username, String password); List&lt;LDAPUser&gt; findByUsernameLikeIgnoreCase(String username);&#125; Provider 12345678910111213141516171819202122232425262728package com.imooc.uaa.security.auth.ldap;import org.springframework.security.authentication.BadCredentialsException;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider;import org.springframework.security.core.AuthenticationException;import org.springframework.security.core.userdetails.UserDetails;import lombok.RequiredArgsConstructor;/**● 展示和 DaoAuthenticationProvider 一起工作的场景 ● 使用 UsernamePasswordAuthenticationToken*/@RequiredArgsConstructorpublic class LDAPMultiAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider &#123;private final LDAPUserRepo ldapUserRepo;@Override protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123;&#125;@Override protected UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123;return ldapUserRepo.findByUsernameAndPassword(username, authentication.getCredentials().toString()).orElseThrow(() -&gt; new BadCredentialsException(&quot;[LDAP] 用户名或密码错误&quot;));&#125; &#125; 将LDAP Provider 加入到Security 配置中 12345678910@Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; // 配置 LdapAuthenticationProvider auth.authenticationProvider(new LDAPMultiAuthenticationProvider(ldapUserRepo)); // 配置 DaoAuthenticationProvider auth .userDetailsService(userDetailsServiceImpl) // 配置 AuthenticationManager 使用 userService .passwordEncoder(passwordEncoder()) // 配置 AuthenticationManager 使用 userService .userDetailsPasswordManager(userDetailsPasswordServiceImpl); // 配置密码自动升级服务 &#125; 建立LADP 模型 ORM层 再配置一个LDAP的Provider 在Provider中配置认证用户的方式。将其加入到Security中。 ProviderManager会扫描到这个Provider 只要所有Provider中有一个认证通过 即认证通过。 相似的，可以用此方法配置其他数据源的认证方式。 5-3 JWT 的概念和创建以及解析 自包含：自己可以验证自己，不需要再去数据库查询 jwt 的承载数据部分是公开的，不能放隐私信息 https://jwt.io/ 12345678910111213141516171819&lt;jjwt.version&gt;0.11.1&lt;/jjwt.version&gt;&lt;!-- JWT 依赖开始 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt; &lt;version&gt;$&#123;jjwt.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt; &lt;version&gt;$&#123;jjwt.version&#125;&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt; &lt;version&gt;$&#123;jjwt.version&#125;&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 5-4 访问令牌和刷新令牌 对于公开的令牌 缩短其有效期 还可以可以综合其方式 如高频访问的ip等手段来防止盗取 刷新令牌 是不能用于访问的，只有一个唯一的用途，获得访问令牌。 前端存放的话 cookie最安全 直接由服务端设置 服务端设置时还可以把域名设置上，只允许这个域名访问。 从yml中配置参数 创建一个Properties类 prefix对应 yml 123456789101112131415161718192021222324252627282930313233public String createAccessToken(UserDetails userDetails) &#123; return createJWTToken(userDetails, appProperties.getJwt().getAccessTokenExpireTime());&#125;public String createRefreshToken(UserDetails userDetails) &#123; return createJWTToken(userDetails, appProperties.getJwt().getRefreshTokenExpireTime(), refreshKey);&#125;public String createJWTToken(UserDetails userDetails, long timeToExpire) &#123; return createJWTToken(userDetails, timeToExpire, key);&#125;/*** 根据用户信息生成一个 JWT** @param userDetails 用户信息* @param timeToExpire 毫秒单位的失效时间* @param signKey 签名使用的 key* @return JWT*/public String createJWTToken(UserDetails userDetails, long timeToExpire, Key signKey) &#123; return Jwts .builder() .setId(&quot;imooc&quot;) .setSubject(userDetails.getUsername()) .claim(&quot;authorities&quot;, userDetails.getAuthorities().stream() .map(GrantedAuthority::getAuthority) .collect(Collectors.toList())) .setIssuedAt(new Date(System.currentTimeMillis())) .setExpiration(new Date(System.currentTimeMillis() + timeToExpire)) .signWith(signKey, SignatureAlgorithm.HS512).compact();&#125; 5-5 创建JwtFilter编写filter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Slf4j@RequiredArgsConstructor@Componentpublic class JwtFilter extends OncePerRequestFilter &#123; private final AppProperties appProperties; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; //1. 检查 JWT Token 是否在 HTTP 报头中 if(checkJwtToken(request)) &#123; //2. 有的话，解析 JWT Token validateToken(request) .filter(claims -&gt; claims.get(&quot;authorities&quot;) != null) .ifPresentOrElse( this::setupSpringAuthentication, // 有值 SecurityContextHolder::clearContext //为空 ); &#125; //3. 无论如何都要继续过滤器链 filterChain.doFilter(request, response); &#125; private void setupSpringAuthentication(Claims claims) &#123; val rawList = CollectionUtil.convertObjectToList(claims.get(&quot;authorities&quot;)); val authorities = rawList.stream() .map(String::valueOf) .map(SimpleGrantedAuthority::new) .collect(toList()); val authentication = new UsernamePasswordAuthenticationToken(claims.getSubject(), null, authorities); //将对象设置进 Security 中 SecurityContextHolder.getContext().setAuthentication(authentication); &#125; private Optional&lt;Claims&gt; validateToken(HttpServletRequest req) &#123; // 从 HTTP 报头中取出 JWT Token String jwtToken = req.getHeader(appProperties.getJwt().getHeader()).replace(appProperties.getJwt().getPrefix(), &quot;&quot;); try &#123; return Optional.of(Jwts.parserBuilder().setSigningKey(JwtUtil.key).build().parseClaimsJws(jwtToken).getBody()); &#125; catch (ExpiredJwtException | SignatureException | MalformedJwtException | UnsupportedJwtException | IllegalArgumentException e) &#123; return Optional.empty(); &#125; &#125; /** * 检查 JWT Token 是否在 HTTP 报头中 * * @param req HTTP 请求 * @return 是否有 JWT Token */ private boolean checkJwtToken(HttpServletRequest req) &#123; String authenticationHeader = req.getHeader(appProperties.getJwt().getHeader()); return authenticationHeader != null &amp;&amp; authenticationHeader.startsWith(appProperties.getJwt().getPrefix()); &#125;&#125; 在config中配置jwtFliter 将其加入到UsernamePasswordAu.. 前面 5-6 实现登录接口和刷新令牌接口重新生成token 利用了 token自包含特性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@PostMapping(&quot;/token&quot;) public Auth login(@Valid @RequestBody LoginDto loginDTO) &#123; return userService.login(loginDTO.getUsername(), loginDTO.getPassword()); &#125; /** * 用户登录 * * @param username 用户名 * @param password 密码 * @return JWT */ public Auth login(String username, String password) &#123; return userRepo.findOptionalByUsername(username) .filter(user -&gt; passwordEncoder.matches(password, user.getPassword())) .map(user -&gt; new Auth(jwtUtil.createAccessToken(user), jwtUtil.createRefreshToken(user))) .orElseThrow(() -&gt; new AccessDeniedException(&quot;用户名密码错误&quot;)); &#125; @PostMapping(&quot;/token/refresh&quot;) public Auth refreshToken(@RequestHeader(name = &quot;Authorization&quot;) String authorization, @RequestParam String refreshToken) &#123; val PREFIX = &quot;Bearer &quot;; val accessToken = authorization.replace(PREFIX, &quot;&quot;); // 1. 验证refreshToken是否有效 // 2. 验证accessToken是否有效 if (jwtUtil.validateRefreshToken(refreshToken) &amp;&amp; jwtUtil.validateWithoutExpiration(accessToken)) &#123; return new Auth(jwtUtil.buildAccessTokenWithRefreshToken(refreshToken), refreshToken); &#125; throw new AccessDeniedException(&quot;Bad Credentials&quot;); &#125; public boolean validateRefreshToken(String jwtToken) &#123; return validateToken(jwtToken, refreshKey); &#125;public boolean validateWithoutExpiration(String jwtToken) &#123; try &#123; Jwts.parserBuilder().setSigningKey(JwtUtil.key).build().parseClaimsJws(jwtToken); return true; &#125; catch (ExpiredJwtException | SignatureException | MalformedJwtException | UnsupportedJwtException | IllegalArgumentException e) &#123; if (e instanceof ExpiredJwtException) &#123; return true; &#125; &#125; return false; &#125; 5-8 完成注册接口 1234567891011121314151617181920212223242526272829303132333435@PostMapping(&quot;/register&quot;) public void register(@Valid @RequestBody UserDto userDto, Locale locale) &#123; // 1. 验证用户名是否存在 if (userService.isUsernameExisted(userDto.getUsername())) &#123; throw new DuplicateProblem(&quot;Exception.duplicate.username&quot;, messageSource, locale); &#125; // 2. 验证邮箱是否存在 if (userService.isEmailExisted(userDto.getEmail())) &#123; throw new DuplicateProblem(&quot;Exception.duplicate.email&quot;, messageSource, locale); &#125; // 3. 验证手机号是否存在 if (userService.isMobileExisted(userDto.getMobile())) &#123; throw new DuplicateProblem(&quot;Exception.duplicate.mobile&quot;, messageSource, locale); &#125; val user = User.builder() .username(userDto.getUsername()) .name(userDto.getName()) .email(userDto.getEmail()) .mobile(userDto.getMobile()) .password(userDto.getPassword()) .build(); userService.register(user); &#125;\t@Transactional public User register(User user) &#123; return roleRepo.findOptionalByAuthority(ROLE_USER) .map(role -&gt; &#123; val userToSave = user .withAuthorities(Set.of(role)) .withPassword(passwordEncoder.encode(user.getPassword())); return userRepo.save(userToSave); &#125;) .orElseThrow(); &#125; 6 6-1 多因子认证和TOTP 可以用多种因素来验证登录 如 指纹、位置。。 redis 主要做缓存 本质就是生成一个在一定时间内不会变的密码，在有效期内输入验证正确即可通过，超过有效期 不能通过 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * 用于一次性验证码 */@Slf4j@Component@RequiredArgsConstructorpublic class TotpUtil &#123; //密码有效期，单位秒 private static final long TIME_STEP = 60 * 5L; //密码长度 private static final int PASSWORD_LENGTH = 6; private KeyGenerator keyGenerator; //key 存储在用户中 private TimeBasedOneTimePasswordGenerator totp; /* * 初始化代码块，Java 8 开始支持。这种初始化代码块的执行在构造函数之前 * 准确说应该是 Java 编译器会把代码块拷贝到构造函数的最开始。 */ &#123; try &#123; totp = new TimeBasedOneTimePasswordGenerator(Duration.ofSeconds(TIME_STEP), PASSWORD_LENGTH); // 生成一个 key keyGenerator = KeyGenerator.getInstance(totp.getAlgorithm()); // SHA-1 and SHA-256 需要 64 字节 (512 位) 的 key; SHA512 需要 128 字节 (1024 位) 的 key keyGenerator.init(512); &#125; catch (NoSuchAlgorithmException e) &#123; log.error(&quot;没有找到算法 &#123;&#125;&quot;, e.getLocalizedMessage()); &#125; &#125; /** * @param time 用于生成 TOTP 的时间 * @return 一次性验证码 * @throws InvalidKeyException 非法 Key 抛出异常 */ public String createTotp(final Key key, final Instant time) throws InvalidKeyException &#123; // 格式化字符串，前面补 0 val format = &quot;%0&quot; + PASSWORD_LENGTH + &quot;d&quot;; return String.format(format, totp.generateOneTimePassword(key, time)); &#125; public Optional&lt;String&gt; createTotp(final String strKey) &#123; try &#123; return Optional.of(createTotp(decodeKeyFromString(strKey), Instant.now())); &#125; catch (InvalidKeyException e) &#123; return Optional.empty(); &#125; &#125; /** * 验证 TOTP * * @param code 要验证的 TOTP * @return 是否一致 * @throws InvalidKeyException 非法 Key 抛出异常 */ public boolean validateTotp(final Key key, final String code) throws InvalidKeyException &#123; val now = Instant.now(); //再创建一个密码，验证是否一致 超过有效期，验证失败 return createTotp(key, now).equals(code); &#125; public Key generateKey() &#123; return keyGenerator.generateKey(); &#125; public String encodeKeyToString(Key key) &#123; return Base64.getEncoder().encodeToString(key.getEncoded()); &#125; public String encodeKeyToString() &#123; return encodeKeyToString(generateKey()); &#125; public Key decodeKeyFromString(String strKey) &#123; return new SecretKeySpec(Base64.getDecoder().decode(strKey), totp.getAlgorithm()); &#125; public long getTimeStepInLong() &#123; return TIME_STEP; &#125; public Duration getTimeStep() &#123; return totp.getTimeStep(); &#125;&#125; 6-2-3 实战发送TOTP阿里云短信 key Id Secret ：认证对 签名需要审核 LeanCloud 和阿里云类似 电子邮件 主要是两种 api smtp 因为有多种发消息的方式，可以先定义一个接口 来限制的方法 123public interface SmsService &#123; void send(String mobile, String msg);&#125; @ConditionalOnProperty 这个配置指 可以在yaml中配置使用 当yml中 mooc.sms-provider.name &#x3D; ali 时会启用这个实现类 没有则不生效 1234567891011121314151617181920212223242526272829303132333435@Slf4j @RequiredArgsConstructor //这个配置指 可以在yaml中配置使用 当yml中 mooc.sms-provider.name = ali 时会启用这个实现类 @ConditionalOnProperty(prefix = &quot;mooc.sms-provider&quot;, name = &quot;name&quot;, havingValue = &quot;ali&quot;) @Service public class SmsServiceAliSmsImpl implements SmsService &#123; private final IAcsClient client; private final AppProperties appProperties; @Override public void send(String mobile, String msg) &#123; //就是构建一个请求 只不过帮我们屏蔽了很多认证的方法 val request = new CommonRequest(); request.setSysMethod(MethodType.POST); request.setSysDomain(appProperties.getSmsProvider().getApiUrl()); request.setSysAction(&quot;SendSms&quot;); request.setSysVersion(&quot;2017-05-25&quot;); request.putQueryParameter(&quot;RegionId&quot;, &quot;cn-hangzhou&quot;); request.putQueryParameter(&quot;PhoneNumbers&quot;, mobile); request.putQueryParameter(&quot;SignName&quot;, &quot;登录验证&quot;); request.putQueryParameter(&quot;TemplateCode&quot;, &quot;SMS_1610048&quot;); request.putQueryParameter(&quot;TemplateParam&quot;, &quot;&#123;\\&quot;code\\&quot;:\\&quot;&quot; + msg + &quot;\\&quot;,\\&quot;product\\&quot;:\\&quot;慕课网实战Spring Security\\&quot;&#125;&quot;); try &#123; val response = client.getCommonResponse(request); log.info(&quot;短信发送结果 &#123;&#125;&quot;, response.getData()); &#125; catch (ServerException e) &#123; log.error(&quot;发送短信时产生服务端异常 &#123;&#125;&quot;, e.getLocalizedMessage()); &#125; catch (ClientException e) &#123; log.error(&quot;发送短信时产生客户端异常 &#123;&#125;&quot;, e.getLocalizedMessage()); &#125; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677@Validated @Configuration @ConfigurationProperties(prefix = &quot;mooc&quot;) public class AppProperties &#123; @Getter @Setter @Valid private Jwt jwt = new Jwt(); @Getter @Setter @Valid private SmsProvider smsProvider = new SmsProvider(); @Getter @Setter @Valid private EmailProvider emailProvider = new EmailProvider(); @Getter @Setter @Valid private LeanCloud leanCloud = new LeanCloud(); @Getter @Setter @Valid private Ali ali = new Ali(); @Getter @Setter public static class Jwt &#123; private String header = &quot;Authorization&quot;; // HTTP 报头的认证字段的 key private String prefix = &quot;Bearer &quot;; // HTTP 报头的认证字段的值的前缀 @Min(5000L) private long accessTokenExpireTime = 60 * 1000L; // Access Token 过期时间 @Min(3600000L) private long refreshTokenExpireTime = 30 * 24 * 3600 * 1000L; // Refresh Token 过期时间 private String key; private String refreshKey; &#125; @Getter @Setter public static class LeanCloud &#123; private String appId; private String appKey; &#125; @Getter @Setter public static class Ali &#123; private String apiKey; private String apiSecret; &#125; @Getter @Setter public static class SmsProvider &#123; private String name; private String apiUrl; &#125; @Getter @Setter public static class EmailProvider &#123; private String name; private String apiKey; &#125; &#125; 123456789101112131415161718192021222324@RequiredArgsConstructor @Slf4j @Service @ConditionalOnProperty(prefix = &quot;mooc.sms-provider&quot;, name = &quot;name&quot;, havingValue = &quot;lean-cloud&quot;) public class SmsServiceLeanCloudSmsImpl implements SmsService &#123; @Override public void send(String mobile, String msg) &#123; val option = new AVSMSOption(); option.setTtl(10); option.setApplicationName(&quot;慕课网实战Spring Security&quot;); option.setOperation(&quot;两步验证&quot;); option.setTemplateName(&quot;登录验证&quot;); option.setSignatureName(&quot;慕课网&quot;); option.setType(AVSMS.TYPE.TEXT_SMS); option.setEnvMap(Map.of(&quot;smsCode&quot;, msg)); AVSMS.requestSMSCodeInBackground(mobile, option) .take(1) .subscribe( (res) -&gt; log.info(&quot;短信发送成功 &#123;&#125;&quot;, res), (err) -&gt; log.error(&quot;发送短信时产生服务端异常 &#123;&#125;&quot;, err.getLocalizedMessage()) ); &#125; &#125; 123456789101112131415161718@RequiredArgsConstructor @Configuration public class LeanCloudConfig &#123; private final AppProperties appProperties; private final Environment env; @PostConstruct()//初始化前执行 public void initialize() &#123; if (env.acceptsProfiles(Profiles.of(&quot;prod&quot;))) &#123; AVOSCloud.setLogLevel(AVLogger.Level.ERROR); &#125; else &#123; AVOSCloud.setLogLevel(AVLogger.Level.DEBUG); &#125; //初始化 AVOSCloud.initialize(appProperties.getLeanCloud().getAppId(), appProperties.getLeanCloud().getAppKey()); &#125; &#125; 1234# 使用环境变量形式来配置 ali: api-key: $&#123;ALI_API_KEY&#125; api-secret: $&#123;ALI_API_SECRET&#125; 6-4 邮件发送123public interface EmailService &#123; void send(String email, String msg);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Slf4j @ConditionalOnProperty(prefix = &quot;mooc.email-provider&quot;, name = &quot;name&quot;, havingValue = &quot;api&quot;) @RequiredArgsConstructor @Service public class EmailServiceApiImpl implements EmailService &#123; private final SendGrid sendGrid; @Override public void send(String email, String msg) &#123; val from = new Email(&quot;service@imooc.com&quot;); val subject = &quot;慕课网实战Spring Security 登录验证码&quot;; val to = new Email(email); val content = new Content(&quot;text/plain&quot;, &quot;验证码为:&quot; + msg); val mail = new Mail(from, subject, to, content); val request = new Request(); try &#123; request.setMethod(Method.POST); request.setEndpoint(&quot;mail/send&quot;); request.setBody(mail.build()); Response response = sendGrid.api(request); if (response.getStatusCode() == 202) &#123; log.info(&quot;邮件发送成功&quot;); &#125; else &#123; log.error(response.getBody()); &#125; &#125; catch (IOException e) &#123; log.error(&quot;请求发生异常 &#123;&#125;&quot;, e.getLocalizedMessage()); &#125; &#125; &#125;@ConditionalOnProperty(prefix = &quot;mooc.email-provider&quot;, name = &quot;name&quot;, havingValue = &quot;smtp&quot;) @RequiredArgsConstructor @Service public class EmailServiceSmtpImpl implements EmailService &#123; private final JavaMailSender emailSender; @Override public void send(String email, String msg) &#123; val message = new SimpleMailMessage(); message.setTo(email); message.setFrom(&quot;service@imooc.com&quot;); message.setSubject(&quot;慕课网实战Spring Security 登录验证码&quot;); message.setText(&quot;验证码为:&quot; + msg); emailSender.send(message); &#125; &#125; 12345678910111213@RequiredArgsConstructor @Configuration public class EmailConfig &#123; private final AppProperties appProperties; //如果有apikey才启动 @ConditionalOnProperty(prefix = &quot;mooc.email-provider&quot;, name = &quot;api-key&quot;) @Bean public SendGrid sendGrid() &#123; return new SendGrid(appProperties.getEmailProvider().getApiKey()); &#125; &#125; 6-5 用户登录逻辑 可以让用户选择是否需要二次认证，也可以管理员设置 当useringMfa 为true时 启用 1.表加字段 2. userService 创建用户时 创建一个mfa key 存入user表中 3. 登录接口 返回mfa 标识和 用户信息key123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@PostMapping(&quot;/token&quot;) public ResponseEntity&lt;?&gt; login(@Valid @RequestBody LoginDto loginDTO) &#123; return userService.findOptionalByUsernameAndPassword(loginDTO.getUsername(), loginDTO.getPassword()) .map(user -&gt; &#123; userService.upgradePasswordEncodingIfNeeded(user, loginDTO.getPassword()); if (!user.isEnabled()) &#123; throw new UserNotEnabledProblem(); &#125; if (!user.isAccountNonLocked()) &#123; throw new UserAccountLockedProblem(); &#125; if (!user.isAccountNonExpired()) &#123; throw new UserAccountExpiredProblem(); &#125; // 不使用多因子认证 if (!user.isUsingMfa()) &#123; return ResponseEntity.ok().body(userService.login(user)); &#125; // 使用多因子认证 //将用户信息缓存起来 val mfaId = userCacheService.cacheUser(user); return ResponseEntity .status(HttpStatus.UNAUTHORIZED) //在请求头中加上 mfa标识 realm id 用于 二次认证时找到这个用户 .header(&quot;X-Authenticate&quot;, &quot;mfa&quot;, &quot;realm=&quot; + mfaId) .build(); &#125;) .orElseThrow(BadCredentialProblem::new); &#125;//校验用户 public Optional&lt;User&gt; findOptionalByUsernameAndPassword(String username, String password) &#123; return findOptionalByUsername(username) .filter(user -&gt; passwordEncoder.matches(password, user.getPassword())); &#125;//密码升级 public void upgradePasswordEncodingIfNeeded(User user, String rawPassword) &#123; if (passwordEncoder.upgradeEncoding(user.getPassword())) &#123; userRepo.save(user.withPassword(passwordEncoder.encode(rawPassword))); &#125; &#125;\t// 用户缓存 private final TotpUtil totpUtil; public String cacheUser(User user) &#123; val mfaId = cryptoUtil.randomAlphanumeric(12); log.debug(&quot;生成 mfaId: &#123;&#125;&quot;, mfaId); RMapCache&lt;String, User&gt; cache = redisson.getMapCache(Constants.CACHE_MFA); if (!cache.containsKey(mfaId)) &#123; cache.put(mfaId, user, totpUtil.getTimeStepInLong(), TimeUnit.SECONDS); &#125; return mfaId; &#125; 4. 选择方式 发送校验码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//生成一个totp@PutMapping(&quot;/totp&quot;) public void sendTotp(@Valid @RequestBody SendTotpDto sendTotpDto) &#123; userCacheService.retrieveUser(sendTotpDto.getMfaId()) //把流 拍扁 返回opt..&lt;&gt; //pair 一次返回两个字 减少包装对象 .flatMap(user -&gt; userService.createTotp(user).map(code -&gt; Pair.of(user, code))) .ifPresentOrElse(pair -&gt; &#123; log.debug(&quot;totp: &#123;&#125;&quot;, pair.getSecond()); if (sendTotpDto.getMfaType() == MfaType.SMS) &#123; smsService.send(pair.getFirst().getMobile(), pair.getSecond()); &#125; else &#123; emailService.send(pair.getFirst().getEmail(), pair.getSecond()); &#125; &#125;, () -&gt; &#123; throw new InvalidTotpProblem(); &#125;); &#125;//验证totp@PostMapping(&quot;/totp&quot;) public Auth verifyTotp(@Valid @RequestBody TotpVerificationDto totpVerificationDto) &#123; return userCacheService.verifyTotp(totpVerificationDto.getMfaId(), totpVerificationDto.getCode()) .map(User::getUsername) .flatMap(userService::findOptionalByUsername) .map(userService::loginWithTotp) .orElseThrow(InvalidTotpProblem::new); &#125; public Optional&lt;User&gt; verifyTotp(String mfaId, String code) &#123; log.debug(&quot;输入参数 mfaId: &#123;&#125;, code: &#123;&#125;&quot;, mfaId, code); RMapCache&lt;String, User&gt; cache = redisson.getMapCache(Constants.CACHE_MFA); if (!cache.containsKey(mfaId) || cache.get(mfaId) == null) &#123; return Optional.empty(); &#125; val cachedUser = cache.get(mfaId); log.debug(&quot;找到用户 &#123;&#125;&quot;, cachedUser); try &#123; val isValid = totpUtil.validateTotp(totpUtil.decodeKeyFromString(cachedUser.getMfaKey()), code); log.debug(&quot;code &#123;&#125; 的验证结果为 &#123;&#125;&quot;, code, isValid); if (!isValid) &#123; return Optional.empty(); &#125; cache.remove(mfaId); log.debug(&quot;移除 mfaId: &#123;&#125;&quot;, mfaId); return Optional.of(cachedUser); &#125; catch (InvalidKeyException e) &#123; log.error(&quot;Key is invalid &#123;&#125;&quot;, e.getLocalizedMessage()); &#125; return Optional.empty(); &#125; 6-8 前端集成1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;uaa-ui&lt;/artifactId&gt; &lt;parent&gt; &lt;groupId&gt;com.imooc&lt;/groupId&gt; &lt;artifactId&gt;mono-uaa&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.github.eirslett&lt;/groupId&gt; &lt;artifactId&gt;frontend-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;frontend-maven-plugin.version&#125;&lt;/version&gt; &lt;executions&gt; &lt;!-- 安装 node.js和npm --&gt; &lt;execution&gt; &lt;id&gt;install node and npm&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;install-node-and-npm&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;nodeVersion&gt;v12.12.0&lt;/nodeVersion&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;!-- 安装项目依赖 --&gt; &lt;execution&gt; &lt;id&gt;npm install&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;npm&lt;/goal&gt; &lt;/goals&gt; &lt;!-- 可选步骤，因为默认的阶段就是&quot;generate-resources&quot; --&gt; &lt;phase&gt;generate-resources&lt;/phase&gt; &lt;configuration&gt; &lt;arguments&gt;install&lt;/arguments&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;!-- 编译构建前端文件 --&gt; &lt;execution&gt; &lt;id&gt;npm run build&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;npm&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;arguments&gt;run build&lt;/arguments&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;!-- 运行单元测试 --&gt; &lt;!-- &lt;execution&gt; &lt;id&gt;npm run test:unit&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;npm&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;test&lt;/phase&gt; &lt;configuration&gt; &lt;arguments&gt;run test:unit&lt;/arguments&gt; &lt;/configuration&gt; &lt;/execution&gt; --&gt; &lt;!-- 运行集成测试 --&gt; &lt;!-- &lt;execution&gt; &lt;id&gt;npm run test:e2e&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;npm&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;test&lt;/phase&gt; &lt;configuration&gt; &lt;arguments&gt;run test:e2e&lt;/arguments&gt; &lt;/configuration&gt; &lt;/execution&gt; --&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 6-9 跨域处理两种方法 避免跨域 前后端放一起。 适用于传统单体项目 前端处理： 设置代理 进行转发 端口映射 后端开启支持 mvc中配置 security 中配置 12345678910111213141516171819202122@Bean CorsConfigurationSource corsConfigurationSource() &#123; CorsConfiguration configuration = new CorsConfiguration(); // 允许跨域访问的主机 if (environment.acceptsProfiles(Profiles.of(&quot;dev&quot;))) &#123; configuration.setAllowedOrigins(Collections.singletonList(&quot;http://localhost:4001&quot;)); &#125; else &#123; configuration.setAllowedOrigins(Collections.singletonList(&quot;https://uaa.imooc.com&quot;)); &#125; //允许的请求方式 configuration.setAllowedMethods(Arrays.asList(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;)); configuration.setAllowedHeaders(Collections.singletonList(&quot;*&quot;)); //开放返回响应请求头 如 用于 totp时返回的请求头 configuration.addExposedHeader(&quot;X-Authenticate&quot;); // 设置 配置bean UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); //把这个配置应用于那些url上 所有的 source.registerCorsConfiguration(&quot;/**&quot;, configuration); return source; &#125;//在安全配置中加入 7 7-1 授权的概念和安全表达式的作用 7-3 方法级注释先在类上开启方法级安全配置 执行方法之前授权 @PreAuthorize 执行方法之前过滤 @PreFilter 执行方法之前授权 @PostAuthorize 执行方法之前过滤 @PostFilter web 请求是成功的 url层 方法后的安全注解： 12345@PostAuthorize(&quot;authentication.name.equals(returnObject.username)&quot;)@GetMapping(&quot;/users/by-email/&#123;email&#125;&quot;)public User getUserByEmail(@PathVariable String email) &#123; return userService.findOptionalByEmail(email).orElseThrow();&#125; 7-3 RBAC 和 角色分级 角色是权限的集合 角色分层体系 一个角色可以包含多个子角色","tags":["认证","springsecurity"]},{"title":"福瑞莱","path":"/2022/11/30/py学习/","content":"​","categories":["公司"]},{"title":"mysql表名列名转小写","path":"/2022/11/12/mysql表名列名转小写/","content":"记录一下，根据工作中项目交付要求，要将MySQL数据库中的表名和字段名中做一个规范，其中就有将表名和字段名统一做小写处理。 废话不多说，直接上MySQL脚本： 批量修改数据库下的表名（大写改小写）： 1234567SELECT concat( &#x27;rename table &#x27; , TABLE_NAME , &#x27; to &#x27; , LOWER(TABLE_NAME) ,&#x27; ;&#x27; ) AS &#x27;修改脚本sql&#x27;FROM information_schema.TABLES t WHERE TABLE_SCHEMA = &#x27;数据库名&#x27;; 批量修改列名（大写改小写）： 123456789101112131415161718192021222324252627282930SELECT\tconcat( &#x27;alter table &#x27;, TABLE_NAME, &#x27; change column &#x27;, COLUMN_NAME, &#x27; &#x27;, LOWER( COLUMN_NAME ), &#x27; &#x27;, COLUMN_TYPE, &#x27; comment \\&#x27;&#x27;, TRIM( REPLACE ( REPLACE ( REPLACE ( REPLACE ( COLUMN_COMMENT, &#x27;,&#x27;, &#x27;:&#x27; ), &#x27;&quot;&#x27;, &#x27;&#x27; ), CHAR ( 10 ), &#x27;&#x27; ), CHAR ( 13 ), &#x27;&#x27; )), &#x27;\\&#x27;&#x27;, &#x27; &#x27;,\tIF ( COLUMN_DEFAULT IS NULL, &#x27;&#x27;, concat( &#x27; default \\&#x27;&#x27;, TRIM( COLUMN_DEFAULT ), &#x27;\\&#x27;&#x27; )), &#x27;;&#x27; ) AS &#x27;修改脚本sql&#x27; FROM\tinformation_schema.COLUMNS t WHERE\tTABLE_SCHEMA = &#x27;数据库名&#x27;; 如果是小写改大写，只需要将LOWER 修改为 UCASE即可。 运行脚本之后会在下面生成修改脚本的SQL，复制出来运行即可完成修改。如下图所示：","tags":["小技巧"]},{"title":"activiti学习","path":"/2022/11/12/activiti学习/","content":"​ 视频地址：https://www.bilibili.com/video/BV1H54y167gf/?p=2 p1-p3.工作流 Activiti7 概述工作流(Workflow)，就是通过计算机对业务流程自动化执行管理。它主要解决的是“使在多个参与者之间按照某种预定义的规则自动进行传递文档、信息或任务的过程，从而实现某个预期的业务目标，或者促使此目标的实现”。 Activiti是一个工作流引擎， activiti可以将业务系统中复杂的业务流程抽取出来，使用专门的建模语言BPMN2.0进行定义，业务流程按照预先定义的流程进行执行，实现了系统的流程由activiti进行管理，减少业务系统由于流程变更进行系统升级改造的工作量，从而提高系统的健壮性，同时也减少了系统开发维护成本。 官方网站：https://www.activiti.org/ BPM（Business Process Management），即业务流程管理，是一种规范化的构造端到端的业务流程 BPMN（Business Process Model AndNotation）- 业务流程模型和符号 是由BPMI（BusinessProcess Management Initiative）开发的一套标准的业务流程建模符号，使用BPMN提供的符号可以创建业务流程。 审批流程： Bpmn图形其实是通过xml表示业务流程，上边的.bpmn文件使用文本编辑器打开： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;definitions xmlns=&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:activiti=&quot;http://activiti.org/bpmn&quot; xmlns:bpmndi=&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot; xmlns:omgdc=&quot;http://www.omg.org/spec/DD/20100524/DC&quot; xmlns:omgdi=&quot;http://www.omg.org/spec/DD/20100524/DI&quot; typeLanguage=&quot;http://www.w3.org/2001/XMLSchema&quot; expressionLanguage=&quot;http://www.w3.org/1999/XPath&quot; targetNamespace=&quot;http://www.activiti.org/test&quot;&gt; &lt;process id=&quot;myProcess&quot; name=&quot;My process&quot; isExecutable=&quot;true&quot;&gt; &lt;startEvent id=&quot;startevent1&quot; name=&quot;Start&quot;&gt;&lt;/startEvent&gt; &lt;userTask id=&quot;usertask1&quot; name=&quot;创建请假单&quot;&gt;&lt;/userTask&gt; &lt;sequenceFlow id=&quot;flow1&quot; sourceRef=&quot;startevent1&quot; targetRef=&quot;usertask1&quot;&gt;&lt;/sequenceFlow&gt; &lt;userTask id=&quot;usertask2&quot; name=&quot;部门经理审核&quot;&gt;&lt;/userTask&gt; &lt;sequenceFlow id=&quot;flow2&quot; sourceRef=&quot;usertask1&quot; targetRef=&quot;usertask2&quot;&gt;&lt;/sequenceFlow&gt; &lt;userTask id=&quot;usertask3&quot; name=&quot;人事复核&quot;&gt;&lt;/userTask&gt; &lt;sequenceFlow id=&quot;flow3&quot; sourceRef=&quot;usertask2&quot; targetRef=&quot;usertask3&quot;&gt;&lt;/sequenceFlow&gt; &lt;endEvent id=&quot;endevent1&quot; name=&quot;End&quot;&gt;&lt;/endEvent&gt; &lt;sequenceFlow id=&quot;flow4&quot; sourceRef=&quot;usertask3&quot; targetRef=&quot;endevent1&quot;&gt;&lt;/sequenceFlow&gt; &lt;/process&gt; &lt;bpmndi:BPMNDiagram id=&quot;BPMNDiagram_myProcess&quot;&gt; &lt;bpmndi:BPMNPlane bpmnElement=&quot;myProcess&quot; id=&quot;BPMNPlane_myProcess&quot;&gt; &lt;bpmndi:BPMNShape bpmnElement=&quot;startevent1&quot; id=&quot;BPMNShape_startevent1&quot;&gt; &lt;omgdc:Bounds height=&quot;35.0&quot; width=&quot;35.0&quot; x=&quot;130.0&quot; y=&quot;160.0&quot;&gt;&lt;/omgdc:Bounds&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=&quot;usertask1&quot; id=&quot;BPMNShape_usertask1&quot;&gt; &lt;omgdc:Bounds height=&quot;55.0&quot; width=&quot;105.0&quot; x=&quot;210.0&quot; y=&quot;150.0&quot;&gt;&lt;/omgdc:Bounds&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=&quot;usertask2&quot; id=&quot;BPMNShape_usertask2&quot;&gt; &lt;omgdc:Bounds height=&quot;55.0&quot; width=&quot;105.0&quot; x=&quot;360.0&quot; y=&quot;150.0&quot;&gt;&lt;/omgdc:Bounds&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=&quot;usertask3&quot; id=&quot;BPMNShape_usertask3&quot;&gt; &lt;omgdc:Bounds height=&quot;55.0&quot; width=&quot;105.0&quot; x=&quot;510.0&quot; y=&quot;150.0&quot;&gt;&lt;/omgdc:Bounds&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=&quot;endevent1&quot; id=&quot;BPMNShape_endevent1&quot;&gt; &lt;omgdc:Bounds height=&quot;35.0&quot; width=&quot;35.0&quot; x=&quot;660.0&quot; y=&quot;160.0&quot;&gt;&lt;/omgdc:Bounds&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNEdge bpmnElement=&quot;flow1&quot; id=&quot;BPMNEdge_flow1&quot;&gt; &lt;omgdi:waypoint x=&quot;165.0&quot; y=&quot;177.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;omgdi:waypoint x=&quot;210.0&quot; y=&quot;177.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;bpmndi:BPMNEdge bpmnElement=&quot;flow2&quot; id=&quot;BPMNEdge_flow2&quot;&gt; &lt;omgdi:waypoint x=&quot;315.0&quot; y=&quot;177.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;omgdi:waypoint x=&quot;360.0&quot; y=&quot;177.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;bpmndi:BPMNEdge bpmnElement=&quot;flow3&quot; id=&quot;BPMNEdge_flow3&quot;&gt; &lt;omgdi:waypoint x=&quot;465.0&quot; y=&quot;177.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;omgdi:waypoint x=&quot;510.0&quot; y=&quot;177.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;bpmndi:BPMNEdge bpmnElement=&quot;flow4&quot; id=&quot;BPMNEdge_flow4&quot;&gt; &lt;omgdi:waypoint x=&quot;615.0&quot; y=&quot;177.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;omgdi:waypoint x=&quot;660.0&quot; y=&quot;177.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;/bpmndi:BPMNPlane&gt; &lt;/bpmndi:BPMNDiagram&gt;&lt;/definitions&gt; p4-p10.使用步骤 部署activiti 定义流程部署 启动流程实例 用户查询待办任务（由activiti接口完成） 用户完成任务（调用activiti接口） 导入依赖： 1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-dependencies&lt;/artifactId&gt; &lt;version&gt;7.0.0.Beta1&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 安装流程设计器 Activiti 在运行时需要数据库的支持，使用25张表，把流程定义节点内容读取到数据库表中，以供后续使用。 Activiti 支持的数据库activiti 支持的数据库和最低版本如下： 数据库类型 版本 JDBC连接示例 说明 h2 1.3.168 jdbc:h2:tcp:&#x2F;&#x2F;localhost&#x2F;activiti 默认配置的数据库 mysql 5.1.21 jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;activiti?autoReconnect&#x3D;true 使用 mysql-connector-java 驱动测试 oracle 11.2.0.1.0 jdbc:oracle:thin:@localhost:1521:xe postgres 8.1 jdbc:postgresql:&#x2F;&#x2F;localhost:5432&#x2F;activiti db2 DB2 10.1 using db2jcc4 jdbc:db2:&#x2F;&#x2F;localhost:50000&#x2F;activiti mssql 2008 using sqljdbc4 jdbc:sqlserver:&#x2F;&#x2F;localhost:1433&#x2F;activiti 在Mysql生成表创建数据库创建 mysql 数据库 activiti （名字任意）： CREATE DATABASE activiti DEFAULT CHARACTER SET utf8; 使用java代码生成表创建 java 工程使用idea 创建 java 的maven工程，取名：activiti01。 加入 maven 依赖的坐标（jar 包）首先需要在 java 工程中加入 ProcessEngine 所需要的 jar 包，包括： activiti-engine-7.0.0.beta1.jar activiti 依赖的 jar 包： mybatis、 alf4j、 log4j 等 activiti 依赖的 spring 包 mysql数据库驱动 第三方数据连接池 dbcp 单元测试 Junit-4.12.jar 我们使用 maven 来实现项目的构建，所以应当导入这些 jar 所对应的坐标到 pom.xml 文件中。 完整的依赖内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;properties&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;activiti.version&gt;7.0.0.Beta1&lt;/activiti.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-engine&lt;/artifactId&gt; &lt;version&gt;$&#123;activiti.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;activiti.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- bpmn 模型处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-bpmn-model&lt;/artifactId&gt; &lt;version&gt;$&#123;activiti.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- bpmn 转换 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-bpmn-converter&lt;/artifactId&gt; &lt;version&gt;$&#123;activiti.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- bpmn json数据转换 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-json-converter&lt;/artifactId&gt; &lt;version&gt;$&#123;activiti.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- bpmn 布局 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-bpmn-layout&lt;/artifactId&gt; &lt;version&gt;$&#123;activiti.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- activiti 云支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti.cloud&lt;/groupId&gt; &lt;artifactId&gt;activiti-cloud-services-api&lt;/artifactId&gt; &lt;version&gt;$&#123;activiti.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 链接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加log4j日志配置我们使用log4j日志包，可以对日志进行配置 在resources 下创建log4j.properties 123456789101112131415# Set root category priority to INFO and its only appender to CONSOLE.#log4j.rootCategory=INFO, CONSOLE debug info warn error fatallog4j.rootCategory=debug, CONSOLE, LOGFILE# Set the enterprise logger category to FATAL and its only appender to CONSOLE.log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE# CONSOLE is set to be a ConsoleAppender using a PatternLayout.log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r[%15.15t] %-5p %30.30c %x - %m # LOGFILE is set to be a File appender using a PatternLayout.log4j.appender.LOGFILE=org.apache.log4j.FileAppenderlog4j.appender.LOGFILE.File=f:\\act\\activiti.loglog4j.appender.LOGFILE.Append=truelog4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayoutlog4j.appender.LOGFILE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r[%15.15t] %-5p %30.30c %x - %m 添加activiti配置文件我们使用activiti提供的默认方式来创建mysql的表。 默认方式的要求是在 resources 下创建 activiti.cfg.xml 文件，注意：默认方式目录和文件名不能修改，因为activiti的源码中已经设置，到固定的目录读取固定文件名的文件。 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexhttp://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 默认id对应的值 为processEngineConfiguration --&gt; &lt;!-- processEngine Activiti的流程引擎 --&gt; &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt; &lt;property name=&quot;jdbcDriver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://1.15.220.36:3306/activiti?useUnicode=true&quot;/&gt; &lt;property name=&quot;jdbcUsername&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;jdbcPassword&quot; value=&quot;123456&quot;/&gt; &lt;!-- activiti数据库表处理策略 --&gt; &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 使用连接池 123456789101112131415161718192021222324252627&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexhttp://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://1.15.220.36:3306/activiti?useUnicode=true&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;property name=&quot;maxActive&quot; value=&quot;3&quot;/&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;1&quot;/&gt; &lt;/bean&gt; &lt;!--在默认方式下 bean的id 固定为 processEngineConfiguration--&gt; &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt; &lt;!--引入上面配置好的 链接池--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--actviti数据库表在生成时的策略 true - 如果数据库中已经存在相应的表，那么直接使用，如果不存在，那么会创建--&gt; &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; java类编写程序生成表创建一个测试类，调用activiti的工具类，生成acitivti需要的数据库表。 直接使用activiti提供的工具类ProcessEngines，会默认读取classpath下的activiti.cfg.xml文件，读取其中的数据库配置，创建 ProcessEngine，在创建ProcessEngine 时会自动创建表。 代码如下： 123456789101112131415161718package com.itheima.activiti01.test;import org.activiti.engine.ProcessEngine;import org.activiti.engine.ProcessEngineConfiguration;import org.junit.Test;public class TestDemo &#123; /** * 生成 activiti的数据库表 */ @Test public void testCreateDbTable() &#123; //使用classpath下的activiti.cfg.xml中的配置创建processEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); System.out.println(processEngine); &#125;&#125; 说明：1、运行以上程序段即可完成 activiti 表创建，通过改变 activiti.cfg.xml 中databaseSchemaUpdate 参数的值执行不同的数据表处理策略。2 、 上 边 的 方法 getDefaultProcessEngine方法在执行时，从activiti.cfg.xml 中找固定的名称 processEngineConfiguration 。 在测试程序执行过程中，idea的控制台会输出日志，说明程序正在创建数据表，类似如下,注意红线内容： 执行完成后我们查看数据库， 创建了 25 张表，结果如下： 到这，我们就完成activiti运行需要的数据库和表的创建。 p11 .activiti的表结构表的命名规则和作用Activiti 的表都以 ACT_ 开头。 第二部分是表示表的用途的两个字母标识。 用途也和服务的 API 对应。ACT_RE ：’RE’表示 repository。 这个前缀的表包含了流程定义和流程静态资源 （图片，规则，等等）。ACT_RU：’RU’表示 runtime。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。 Activiti 只在流程实例执行过程中保存这些数据， 在流程结束时就会删除这些记录。 这样运行时表可以一直很小速度很快。ACT_HI：’HI’表示 history。 这些表包含历史数据，比如历史流程实例， 变量，任务等等。 ACT_GE ： GE 表示 general。 通用数据， 用于不同场景下 Activiti数据表介绍 表分类 表名 解释 一般数据 [ACT_GE_BYTEARRAY] 通用的流程定义和流程资源 [ACT_GE_PROPERTY] 系统相关属性 流程历史记录 [ACT_HI_ACTINST] 历史的流程实例 [ACT_HI_ATTACHMENT] 历史的流程附件 [ACT_HI_COMMENT] 历史的说明性信息 [ACT_HI_DETAIL] 历史的流程运行中的细节信息 [ACT_HI_IDENTITYLINK] 历史的流程运行过程中用户关系 [ACT_HI_PROCINST] 历史的流程实例 [ACT_HI_TASKINST] 历史的任务实例 [ACT_HI_VARINST] 历史的流程运行中的变量信息 流程定义表 [ACT_RE_DEPLOYMENT] 部署单元信息 [ACT_RE_MODEL] 模型信息 [ACT_RE_PROCDEF] 已部署的流程定义 运行实例表 [ACT_RU_EVENT_SUBSCR] 运行时事件 [ACT_RU_EXECUTION] 运行时流程执行实例 [ACT_RU_IDENTITYLINK] 运行时用户关系信息，存储任务节点与参与者的相关信息 [ACT_RU_JOB] 运行时作业 [ACT_RU_TASK] 运行时任务 [ACT_RU_VARIABLE] 运行时变量表 p12-p14.Activiti体系架构类关系图 Activiti7 IdentityService，FormService两个Serivce都已经删除了。 前两个字母对应相关表 SpringProcessEngineConfiguration配置通过org.activiti.spring.SpringProcessEngineConfiguration 与Spring整合。 创建spring与activiti的整合配置文件： activity-spring.cfg.xml（名称可修改） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.1.xsd &quot;&gt; &lt;!-- 工作流引擎配置bean --&gt; &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.spring.SpringProcessEngineConfiguration&quot;&gt; &lt;!-- 数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 使用spring事务管理器 --&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt; &lt;!-- 数据库策略 --&gt; &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;drop-create&quot; /&gt; &lt;!-- activiti的定时任务关闭 --&gt; &lt;property name=&quot;jobExecutorActivate&quot; value=&quot;false&quot; /&gt; &lt;/bean&gt; &lt;!-- 流程引擎 --&gt; &lt;bean id=&quot;processEngine&quot; class=&quot;org.activiti.spring.ProcessEngineFactoryBean&quot;&gt; &lt;property name=&quot;processEngineConfiguration&quot; ref=&quot;processEngineConfiguration&quot; /&gt; &lt;/bean&gt; &lt;!-- 资源服务service --&gt; &lt;bean id=&quot;repositoryService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getRepositoryService&quot; /&gt; &lt;!-- 流程运行service --&gt; &lt;bean id=&quot;runtimeService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getRuntimeService&quot; /&gt; &lt;!-- 任务管理service --&gt; &lt;bean id=&quot;taskService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getTaskService&quot; /&gt; &lt;!-- 历史管理service --&gt; &lt;bean id=&quot;historyService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getHistoryService&quot; /&gt; &lt;!-- 用户管理service --&gt; &lt;bean id=&quot;identityService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getIdentityService&quot; /&gt; &lt;!-- 引擎管理service --&gt; &lt;bean id=&quot;managementService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getManagementService&quot; /&gt; &lt;!-- 数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/activiti&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;mysql&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;3&quot; /&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;1&quot; /&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt;&lt;/tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 切面，根据具体项目修改切点配置 --&gt; &lt;aop:config proxy-target-class=&quot;true&quot;&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.itheima.ihrm.service.impl.*.(..))&quot;* /&gt; &lt;/aop:config&gt;&lt;/beans&gt; 创建processEngineConfiguration1ProcessEngineConfiguration configuration = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(&quot;activiti.cfg.xml&quot;) ​ 上边的代码要求activiti.cfg.xml中必须有一个processEngineConfiguration的bean 也可以使用下边的方法，更改bean 的名字： 1ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(String resource, String beanName); 工作流引擎创建工作流引擎（ProcessEngine），相当于一个门面接口，通过ProcessEngineConfiguration创建processEngine，通过ProcessEngine创建各个service接口。 默认创建方式将activiti.cfg.xml文件名及路径固定，且activiti.cfg.xml文件中有 processEngineConfiguration的配置， 可以使用如下代码创建processEngine: 123//直接使用工具类 ProcessEngines，使用classpath下的activiti.cfg.xml中的配置创建processEngineProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();System.out.println(processEngine); 一般创建方式1234//先构建ProcessEngineConfigurationProcessEngineConfiguration configuration = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(&quot;activiti.cfg.xml&quot;);//通过ProcessEngineConfiguration创建ProcessEngine，此时会创建数据库ProcessEngine processEngine = configuration.buildProcessEngine(); Servcie服务接口Service是工作流引擎提供用于进行工作流部署、执行、管理的服务接口，我们使用这些接口可以就是操作服务对应的数据表 Service创建方式通过ProcessEngine创建Service 方式如下： 123RuntimeService runtimeService = processEngine.getRuntimeService();RepositoryService repositoryService = processEngine.getRepositoryService();TaskService taskService = processEngine.getTaskService(); Service总览 service名称 service作用 RepositoryService activiti的资源管理类 RuntimeService activiti的流程运行管理类 TaskService activiti的任务管理类 HistoryService activiti的历史管理类 ManagerService activiti的引擎管理类 简单介绍： RepositoryService 是activiti的资源管理类，提供了管理和控制流程发布包和流程定义的操作。使用工作流建模工具设计的业务流程图需要使用此service将流程定义文件的内容部署到计算机。 RuntimeServiceActiviti的流程运行管理类。可以从这个服务类中获取很多关于流程执行相关的信息 TaskServiceActiviti的任务管理类。可以从这个类中获取任务的信息。 HistoryServiceActiviti的历史管理类，可以查询历史信息，执行流程时，引擎会保存很多数据（根据配置），比如流程实例启动时间，任务的参与者， 完成任务的时间，每个流程实例的执行路径，等等。 这个服务主要通过查询功能来获得这些数据。 ManagementServiceActiviti的引擎管理类，提供了对 Activiti 流程引擎的管理和维护功能，这些功能不在工作流驱动的应用程序中使用，主要用于 Activiti 系统的日常维护。 p14.Activiti入门在本章内容中，我们来创建一个Activiti工作流，并启动这个流程。 创建Activiti工作流主要包含以下几步： 1、定义流程，按照BPMN的规范，使用流程定义工具，用流程符号把整个流程描述出来 2、部署流程，把画好的流程定义文件，加载到数据库中，生成表的数据 3、启动流程，使用java代码来操作数据库表中的内容 p15.流程符号BPMN 2.0是业务流程建模符号2.0的缩写。 它由Business Process Management Initiative这个非营利协会创建并不断发展。作为一种标识，BPMN 2.0是使用一些符号来明确业务流程设计流程图的一整套符号规范，它能增进业务建模时的沟通效率。 目前BPMN2.0是最新的版本，它用于在BPM上下文中进行布局和可视化的沟通。 接下来我们先来了解在流程设计中常见的 符号。 BPMN2.0的基本符合主要包含： 事件 Event 活动 Activity活动是工作或任务的一个通用术语。一个活动可以是一个任务，还可以是一个当前流程的子处理流程； 其次，你还可以为活动指定不同的类型。常见活动如下： 网关 GateWay网关用来处理决策，有几种常用网关需要了解： 排他网关 (x)——只有一条路径会被选择。流程执行到该网关时，按照输出流的顺序逐个计算，当条件的计算结果为true时，继续执行当前网关的输出流； ​ 如果多条线路计算结果都是 true，则会执行第一个值为 true 的线路。如果所有网关计算结果没有true，则引擎会抛出异常。 ​ 排他网关需要和条件顺序流结合使用，default 属性指定默认顺序流，当所有的条件不满足时会执行默认顺序流。 并行网关 (+)——所有路径会被同时选择 ​ 拆分 —— 并行执行所有输出顺序流，为每一条顺序流创建一个并行执行线路。 ​ 合并 —— 所有从并行网关拆分并执行完成的线路均在此等候，直到所有的线路都执行完成才继续向下执行。 包容网关 (+)—— 可以同时执行多条线路，也可以在网关上设置条件 ​ 拆分 —— 计算每条线路上的表达式，当表达式计算结果为true时，创建一个并行线路并继续执行 ​ 合并 —— 所有从并行网关拆分并执行完成的线路均在此等候，直到所有的线路都执行完成才继续向下执行。 事件网关 (+)—— 专门为中间捕获事件设置的，允许设置多个输出流指向多个不同的中间捕获事件。当流程执行到事件网关后，流程处于等待状态，需要等待抛出事件才能将等待状态转换为活动状态。 流向 Flow流是连接两个流程节点的连线。常见的流向包含以下几种： P20-p21.流程定义部署概述将上面在设计器中定义的流程部署到activiti数据库中，就是流程定义部署。 通过调用activiti的api将流程定义的bpmn和png两个文件一个一个添加部署到activiti中，也可以将两个文件打成zip包进行部署。 单个文件部署方式分别将bpmn文件和png图片文件部署。 123456789101112131415161718192021222324252627282930package com.itheima.test;import org.activiti.engine.ProcessEngine;import org.activiti.engine.ProcessEngines;import org.activiti.engine.RepositoryService;import org.activiti.engine.repository.Deployment;import org.junit.Test;public class ActivitiDemo &#123; /** * 部署流程定义 */ @Test public void testDeployment()&#123;// 1、创建ProcessEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();// 2、得到RepositoryService实例 RepositoryService repositoryService = processEngine.getRepositoryService();// 3、使用RepositoryService进行部署 Deployment deployment = repositoryService.createDeployment() .addClasspathResource(&quot;bpmn/evection.bpmn&quot;) // 添加bpmn资源 .addClasspathResource(&quot;bpmn/evection.png&quot;) // 添加png资源 .name(&quot;出差申请流程&quot;) .deploy();// 4、输出部署信息 System.out.println(&quot;流程部署id：&quot; + deployment.getId()); System.out.println(&quot;流程部署名称：&quot; + deployment.getName()); &#125;&#125; 执行此操作后activiti会将上边代码中指定的bpm文件和图片文件保存在activiti数据库。 压缩包部署方式将evection.bpmn和evection.png压缩成zip包。 1234567891011121314151617181920@Test\tpublic void deployProcessByZip() &#123; // 定义zip输入流 InputStream inputStream = this .getClass() .getClassLoader() .getResourceAsStream( &quot;bpmn/evection.zip&quot;); ZipInputStream zipInputStream = new ZipInputStream(inputStream); // 获取repositoryService RepositoryService repositoryService = processEngine .getRepositoryService(); // 流程部署 Deployment deployment = repositoryService.createDeployment() .addZipInputStream(zipInputStream) .deploy(); System.out.println(&quot;流程部署id：&quot; + deployment.getId()); System.out.println(&quot;流程部署名称：&quot; + deployment.getName());\t&#125; 执行此操作后activiti会将上边代码中指定的bpm文件和图片文件保存在activiti数据库。 操作数据表流程定义部署后操作activiti的3张表如下： act_re_deployment 流程定义部署表，每部署一次增加一条记录 act_re_procdef 流程定义表，部署每个新的流程定义都会在这张表中增加一条记录 act_ge_bytearray 流程资源表 接下来我们来看看，写入了什么数据： 1SELECT * FROM act_re_deployment #流程定义部署表，记录流程部署信息 结果： 1SELECT * FROM act_re_procdef #流程定义表，记录流程定义信息 结果： 注意，KEY 这个字段是用来唯一识别不同流程的关键字 1SELECT * FROM act_ge_bytearray #资源表 结果： 注意： act_re_deployment和act_re_procdef一对多关系，一次部署在流程部署表生成一条记录，但一次部署可以部署多个流程定义，每个流程定义在流程定义表生成一条记录。每一个流程定义在act_ge_bytearray会存在两个资源记录，bpmn和png。 建议：一次部署一个流程，这样部署表和流程定义表是一对一有关系，方便读取流程部署及流程定义信息。 p22- .启动流程实例流程定义部署在activiti后就可以通过工作流管理业务流程了，也就是说上边部署的出差申请流程可以使用了。 针对该流程，启动一个流程表示发起一个新的出差申请单，这就相当于java类与java对象的关系，类定义好后需要new创建一个对象使用，当然可以new多个对象。对于请出差申请流程，张三发起一个出差申请单需要启动一个流程实例，出差申请单发起一个出差单也需要启动一个流程实例。 代码如下： 123456789101112131415161718 /** * 启动流程实例 */ @Test public void testStartProcess()&#123;// 1、创建ProcessEngine ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();// 2、获取RunTimeService RuntimeService runtimeService = processEngine.getRuntimeService();// 3、根据流程定义Id启动流程 ProcessInstance processInstance = runtimeService .startProcessInstanceByKey(&quot;myEvection&quot;);// 输出内容 System.out.println(&quot;流程定义id：&quot; + processInstance.getProcessDefinitionId()); System.out.println(&quot;流程实例id：&quot; + processInstance.getId()); System.out.println(&quot;当前活动Id：&quot; + processInstance.getActivityId()); &#125; 输出内容如下： 操作数据表 act_hi_actinst 流程实例执行历史 act_hi_identitylink 流程的参与用户历史信息 act_hi_procinst 流程实例历史信息 act_hi_taskinst 流程任务历史信息 act_ru_execution 流程执行信息 act_ru_identitylink 流程的参与用户信息 act_ru_task 任务信息"},{"title":"docker学习","path":"/2022/11/12/docker学习/","content":"Docker安装：https://blog.csdn.net/qq_43418737/article/details/125707321 常用命令帮助启动类命令 123456789101112131415· 启动docker： systemctl start docker· 停止docker： systemctl stop docker· 重启docker： systemctl restart docker· 查看docker状态： systemctl status docker· 开机启动： systemctl enable docker· 查看docker概要信息： docker info· 查看docker总体帮助文档： docker --help· 查看docker命令帮助文档： docker 具体命令 --help 镜像命令· docker images · 列出本地主机上的镜像 各个选项说明: 12345REPOSITORY：表示镜像的仓库源TAG：镜像的标签版本号IMAGE ID：镜像IDCREATED：镜像创建时间SIZE：镜像大小 同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像 · 下载镜像 1234567891011· docker pull 镜像名字[:TAG]· docker pull 镜像名字· 没有TAG就是最新版· 等价于· docker pull 镜像名字:latest· docker pull ubuntu · docker system df 查看镜像&#x2F;容器&#x2F;数据卷所占的空间 · docker rmi 某个XXX镜像名字ID · 删除镜像 面试题：谈谈docker虚悬镜像是什么？· 仓库名、标签都是的镜像，俗称虚悬镜像dangling image 容器命令安装可视化面板 https://blog.csdn.net/weixin_46152207/article/details/125936769 设置挂载目录启动Jenkins 12docker run -d -v /data/jenkins/jenkins_home:/var/jenkins_home -p 9010:8080 -p 50000:50000 --restart=on-failure jenkins/jenkins:lts-jdk11 docker 启动nacos 1docker run --name nacos -d -p 8848:8848 -p 9848:9848 -p 9849:9849 --privileged=true --restart=always -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -e PREFER_HOST_MODE=hostname -e SPRING_DATASOURCE_PLATFORM=mysql -e MYSQL_SERVICE_HOST=1.15.220.36 -e MYSQL_SERVICE_PORT=3306 -e MYSQL_SERVICE_DB_NAME=nacos_config -e MYSQL_SERVICE_USER=root -e MYSQL_SERVICE_PASSWORD=123456 -v /root/apply/docker/apply/nacos/logs:/home/nacos/logs -v /root/apply/docker/apply/nacos/init.d/custom.properties:/etc/nacos/init.d/custom.properties -v /root/apply/docker/apply/nacos/data:/home/nacos/data nacos/nacos-server 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354docker 启动容器docker run \\容器名称叫nacos -d后台运行--name nacos -d acos默认端口8848 映射到外部端口8848-p 8848:8848 aocs 应该是2.0版本以后就需要一下的两个端口 所以也需要开放-p 9848:9848 -p 9849:9849 --privileged=true \\docker重启时 nacos也一并重启--restart=always \\-e 配置 启动参数配置 jvm-e JVM_XMS=256m -e JVM_XMX=256m \\单机模式-e MODE=standalone -e PREFER_HOST_MODE=hostname \\数据库是mysql 配置持久化 不使用nacos自带的数据库-e SPRING_DATASOURCE_PLATFORM=mysql \\写自己的数据库地址-e MYSQL_SERVICE_HOST=###### \\数据库端口号-e MYSQL_SERVICE_PORT=3306 \\mysql的数据库名称-e MYSQL_SERVICE_DB_NAME=nacos \\mysql的账号密码-e MYSQL_SERVICE_USER=root -e MYSQL_SERVICE_PASSWORD=root \\-v 映射docker内部的文件到docker外部 我这里将nacos的日志 数据 以及配置文件 映射出来映射日志-v /root/apply/docker/apply/nacos/logs:/home/nacos/logs \\映射配置文件 (应该没用了 因为前面已经配置参数了)-v /root/apply/docker/apply/nacos/init.d/custom.properties:/etc/nacos/init.d/custom.properties \\映射nacos的本地数据 也没啥用因为使用了mysql-v /root/apply/docker/apply/nacos/data:/home/nacos/data \\启动镜像名称nacos/nacos-server"},{"title":"git","path":"/2022/11/08/git/","content":"​ 安装与配置 一般选择默认即可 设置默认编辑器，一般选择vim 基本上 git安装全选默认配置就好","tags":["工具"],"categories":["工具"]},{"title":"SpringCloud学习","path":"/2022/11/01/SpringCloud学习/","content":"Boot和Cloud版本选型版本对应地址：https://spring.io/projects/spring-cloud 详细信息：https://start.spring.io/actuator/info 本次版本选型 Cloud组件 父工程创建 约定&gt;配置&gt;编码 ：先选定好框架和配置再开始编码 总父工程 各个模块 工程创建后 设置字符编码 开启注解支持 选择java编译版本 文件类型过滤 Pom依赖管理需要注意boot版本和cloud版本对应,下面是课程源码复制过来的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495!-- 统一管理jar包版本 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.18.12&lt;/lombok.version&gt; &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt; &lt;druid.version&gt;1.1.16&lt;/druid.version&gt; &lt;mybatis.spring.boot.version&gt;1.3.0&lt;/mybatis.spring.boot.version&gt; &lt;/properties&gt; &lt;!-- 子模块继承之后，提供作用：锁定版本+子modlue不用写groupId和version --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--spring boot 2.2.2--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring cloud Hoxton.SR1--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.spring.boot.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;","tags":["SpringCloud"]},{"title":"javase","path":"/2022/10/31/javase复习/","content":"​ 单例模式 饿汉式：直接创建对象，不存在线程安全问题 直接实例化饿汉式（简洁直观） 枚举类（最简洁） 静态代码块（适合复杂实例化） 用于在配置文件中读取配置 初始化对象 懒汉式：延迟创建对象 线程不安全 线程安全（ 双重检查 ） 静态内部类 ：内部类不会随着外部类创建和初始化而初始化 类初始化过程 一个类要创建实列，需要先加载并初始化该类 main方法所在的类需要先加载和初始化 一个子类要初始化需要先初始化父类 一个类初始化就是执行()方法 ()方法由静态类变量显示赋值代码和静态代码块组成 类变量显示赋值代码和静态代码块代码从上到下顺序执行 ()方法只执行一次 实列初始化过程","tags":["javas"],"categories":["java"]},{"title":"redis学习小记","path":"/2022/07/09/redis学习小记/","content":"基础基本数据类型 String 字符串 Hash 哈希表 List 有序集合 可重复 Set 无序集合 不重复 SortedSet 可排序集合 不重复 通用命令 keys 查询key keys * 查询所有key 模糊查询占用资源 堵塞进程 生产不使用 del 删除一个或多个key mest 批量添加k -v exists 判断一个key 是否存在 expire 给一个key设置有效期 ttl 查询一个key的有效期 String 类型1234567value 是字符串 根据字符串的格式不同 又可以分为3类：String：普通字符串int：整形 可以做自增自减操作float：浮点 可以做自增自减操作如果是数字类型 会转为二进制进行存储 节省空间字符串只能转为字节码最大512m key的结构12可以通过多个单词形成层级结构,多个单词之间用：隔开 如 项目：业务：用户 Hash类型123hash类型也叫散列，value是一个无序字典，类似java hashMapString结构是将对象序列化为json字符串存储，但需要对其某个字段修改时很不方便Hash结构可以将对象中每个字段独立存储，可针对单个字段crud List类型123456789与jav中linkedList类似，可以看作一个双向链表 支持正反向检索有序元素可重复插入删除快 查询速度一般lpush key element 向左侧插入lpop 从左侧取出rpush key element 向右侧插入rpop blpop key timeout 指定一个时间内阻塞从左边取出 Set类型12345678910111213与java中HashSet类似 可以看作一个value为null的HashMap无序不可重复查找快支持 交集 并集 差集 等功能sadd key member... 向set中添加元素srem key member... 移除set中元素scard key 返回set中元素个数sismember key member 判断set中是否存在一个元素sinter key1 key2 ... 求交集sdiff key1 key2... 求交集sunion key1 key2 求并集 SortedSet类型12345678910是一个可排序的set集合 功能上和java中TreeSet类似，但是底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性（分数），可以基于score属性对元素排序 底层是一个跳表（SkipList）加Hash表实现。可排序不可重复查询速度快一般用来实现排行榜功能排名默认升序 命令后加REV 反转 降序zscore key member 获取指定元素score值zrank key member 获取指定元素排名zrange key min max 获取指定名次内元素 Java使用Redis123456https://redis.io/clientsJedis: Jedis实列线程不安全，多线程操作需要基于连接池使用Lettuce： 基于Netty实现 支持同步,异步和响应式编程 线程安全 支持redis 哨兵模式，集群模式和管道模式Redisson: 基于redis实现的分布式，在分布式环境下推荐使用springData Redis 兼容了 Jedis和Lettuce redis 序列化1234567afterPropertiesSet()&#123;\tif (defaultSerializer == null) &#123; defaultSerializer = new JdkSerializationRedisSerializer( classLoader != null ? classLoader : this.getClass().getClassLoader()); &#125;&#125;如果没有指定序列化方式 默认使用jdk的二进制序列化 （可读性差） redis序列化修改123456789101112131415161718@Bean public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123; //1 创建对象 RedisTemplate&lt;String , Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); //2 设置链接工厂 redisTemplate.setConnectionFactory(redisConnectionFactory); //3 参加json序列化对象 GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); //4 设置key序列化格式为字符串 redisTemplate.setKeySerializer(RedisSerializer.string()); redisTemplate.setHashKeySerializer(RedisSerializer.string()); //5 设置value序列化方式为json redisTemplate.setValueSerializer(jsonRedisSerializer); redisTemplate.setHashValueSerializer(jsonRedisSerializer); return redisTemplate; &#125;","tags":["中间件","redis"],"categories":["中间件"]},{"path":"/customize/css/ZYDark.css","content":"#ZYDark:root { --site-bg: #1c1e21; --card: #373d43; --block: #26292c; --block-border: #383d42; --block-hover: #2f3337; --text-p0: #fff; --text-p1: #ccc; --text-p2: #b3b3b3; --text-p3: #858585; --text-p4: #707070; --text-meta: #4d4d4d; --text-code: #ff6333; } @media screen and (max-width: 667px) { #ZYDark:root { --site-bg: #000; } } #ZYDark:root { --blur-bg: rgba(0,0,0,0.5); } #ZYDark .float-panel { --blur-bg: rgba(0,0,0,0.4); } #ZYDark .tag-plugin.tag { --theme: #ff6333; --theme-bg1: #3d1e14; --theme-bg2: #2f2522; --theme-border: #5c2d1f; --text-p0: #ffc4b3; --text-p1: #dfae9f; --text-p2: #f1997e; } #ZYDark .tag-plugin[color='red'] { --theme: #f44336; --theme-bg1: #3d1714; --theme-bg2: #2f2322; --theme-border: #5c231f; --text-p0: #ffb8b3; --text-p1: #dfa49f; --text-p2: #f1867e; } #ZYDark .tag-plugin[color='orange'] { --theme: #fa6400; --theme-bg1: #3d2514; --theme-bg2: #2f2722; --theme-border: #5c371f; --text-p0: #ffd1b3; --text-p1: #dfb99f; --text-p2: #f1ac7e; } #ZYDark .tag-plugin[color='yellow'] { --theme: #ffbd2b; --theme-bg1: #3d3014; --theme-bg2: #2f2b22; --theme-border: #5c491f; --text-p0: #ffe7b3; --text-p1: #dfcb9f; --text-p2: #f1cd7e; } #ZYDark .tag-plugin[color='green'] { --theme: #3dc550; --theme-bg1: #143d1a; --theme-bg2: #222f24; --theme-border: #1f5c27; --text-p0: #b3ffbd; --text-p1: #9fdfa8; --text-p2: #7ef18e; } #ZYDark .tag-plugin[color='cyan'] { --theme: #1bcdfc; --theme-bg1: #14353d; --theme-bg2: #222d2f; --theme-border: #1f4f5c; --text-p0: #b3efff; --text-p1: #9fd2df; --text-p2: #7ed9f1; } #ZYDark .tag-plugin[color='blue'] { --theme: #2196f3; --theme-bg1: #142b3d; --theme-bg2: #222a2f; --theme-border: #1f415c; --text-p0: #b3ddff; --text-p1: #9fc3df; --text-p2: #7ebef1; } #ZYDark .tag-plugin[color='purple'] { --theme: #9c27b0; --theme-bg1: #37143d; --theme-bg2: #2d222f; --theme-border: #531f5c; --text-p0: #f4b3ff; --text-p1: #d69fdf; --text-p2: #e07ef1; } #ZYDark .tag-plugin[color='light'] { --theme-border: #fff; --theme-bg1: #e0e0e0; --theme-bg2: #fff; --text-p0: #000; --text-p1: #111; --text-p2: #1f1f1f; --text-p3: #555; --text-code: #fff; } #ZYDark .tag-plugin[color='dark'] { --theme-border: #000; --theme-bg1: #1f1f1f; --theme-bg2: #111; --text-p0: #fff; --text-p1: #fff; --text-p2: #e0e0e0; --text-p3: #ddd; --text-code: #fff; } #ZYDark .tag-plugin[color='warning'], #ZYDark .tag-plugin[color='light'] { --text-p0: #000; --text-p1: #111; --text-p2: #1f1f1f; --text-p3: #555; --text-code: #fff; } #ZYDark .social-wrap a.social:hover { box-shadow: none; } /* waline评论样式 */ #ZYDark .wl-count{ padding: .375em; font-weight: bold; font-size: 1.25em; color: #fff; } #ZYDark .cmt-body.waline{ --waline-white: #000; --waline-light-grey: #666; --waline-dark-grey: #999; /* 布局颜色 */ --waline-color: #fff; --waline-bgcolor: var(--block); --waline-bgcolor-light: #272727; --waline-border-color: #333; --waline-disable-bgcolor: #444; --waline-disable-color: #272727; /* 特殊颜色 */ --waline-bq-color: #272727; /* 其他颜色 */ --waline-info-bgcolor: #272727; --waline-info-color: #666; }"},{"path":"/customize/js/ZYDark.js","content":"/** * 监听系统主题 * @type {MediaQueryList} */ var OSTheme = window.matchMedia('(prefers-color-scheme: dark)'); OSTheme.addListener(e => { if (window.localStorage.getItem('ZYI_Theme_Mode') === 'Moss') { ThemeChange('Moss'); } }) /** * 修改博客主题 * @param theme 亮为light,暗为dark,自动为auto * @constructor */ const ThemeChange = (theme) => { if(document.querySelector(\"#start > aside > footer > div > a:nth-child(2)\") != 'undefined' && document.querySelector(\"#start > aside > footer > div > a:nth-child(2)\") != null){ if (theme === 'light' || (theme === 'Moss' && !OSTheme.matches)) { document.querySelector(\"html\").id = \"ZYLight\"; document.querySelector(\"#start > aside > footer > div > a:nth-child(2)\").style.filter = 'grayscale(0%)'; document.querySelector(\"#start > aside > footer > div > a:nth-child(1)\").style.filter = 'grayscale(100%)'; } else { document.querySelector(\"html\").id = \"ZYDark\"; document.querySelector(\"#start > aside > footer > div > a:nth-child(1)\").style.filter = 'grayscale(0%)'; document.querySelector(\"#start > aside > footer > div > a:nth-child(2)\").style.filter = 'grayscale(100%)'; } //if (theme === 'Moss') { document.querySelector(\"#start > aside > footer > div > a:nth-child(7)\").style.filter = 'grayscale(0%)'; } //else { document.querySelector(\"#start > aside > footer > div > a:nth-child(7)\").style.filter = 'grayscale(100%)'; } window.localStorage.setItem('ZYI_Theme_Mode', theme); commentChange(theme); } } // /** // * 修改评论主题 // * @param theme // */ // const commentChange = (theme) => { // try { // let commentSrc = document.querySelector(\"#comments > section.body.cmt-body.giscus > iframe\").src; // if (theme === \"Moss\") { // theme = OSTheme.matches? 'dark' : 'light'; // } // commentSrc = commentSrc.replace(theme === 'dark' ? 'theme=light' : 'theme=dark', theme === 'dark' ? 'theme=dark' : 'theme=light'); // commentSrc = commentSrc.replace('theme=preferred_color_scheme', theme === 'dark' ? 'theme=dark' : 'theme=light'); // document.querySelector(\"#comments > section.body.cmt-body.giscus > iframe\").src = commentSrc; // } catch (e) { // } // } /** * 初始化博客主题 */ switch (window.localStorage.getItem('ZYI_Theme_Mode')) { case 'light': ThemeChange('light'); break; case 'dark': ThemeChange('dark'); break; default: ThemeChange('Moss'); } if(document.querySelector(\"#start > aside > footer > div > a:nth-child(2)\") != 'undefined' && document.querySelector(\"#start > aside > footer > div > a:nth-child(2)\") != null){ /** * 切换主题模式 */ document.querySelector(\"#start > aside > footer > div > a:nth-child(1)\").onclick = () => { ThemeChange('dark'); } document.querySelector(\"#start > aside > footer > div > a:nth-child(2)\").onclick = () => { ThemeChange('light'); } //document.querySelector(\"#start > aside > footer > div > a:nth-child(7)\").onclick = () => { // ThemeChange('Moss'); //} }"}]